arXiv:1404.3458v2 [cs.IT] 24 Jul 2014

Novel Polynomial Basis and Its Application to
Reed-Solomon Erasure Codes
Sian-Jheng Lin, Wei-Ho Chung

Yunghsiang S. Han

Research Center for Information Technology Innovation
Academia Sinica
Taipei City, Taiwan
Email: sjhenglin@gmail.com; whc@citi.sinica.edu.tw

Department of Electrical Engineering
National Taiwan University of Science and Technology
Taipei City, Taiwan
Email: yshan@mail.ntust.edu.tw

the polynomial evaluations. The new basis possesses a recursive structure which can be exploited to compute the
polynomial evaluations at a period of h consecutive points
in time O(h lg(h)) with small leading constant. Furthermore,
the recursive structure also works in formal derivative with
time complexity O(h lg(h)).
An application of the proposed polynomial basis is in
erasure codes, that is an error-correcting code by converting a
message of k symbols into a codeword with n symbols such
that the original message can be recovered from a subset of
the n symbols. An (n, k) erasure code is called Maximum
Distance Separable (MDS) if any k out of the n codeword
symbols are sufficient to reconstruct the original message. A
typical class of MDS codes is Reed-Solomon (RS) codes [1].
Nowadays, RS codes have been applied to many applications,
such as RAID systems [2, 3], distributed storage codes [4, 5],
and data carousel [6]. Hence, the computational complexity
of RS erasure code is considered crucial and has attracted
substantial research attention. Based on the new polynomial
basis, this paper presents the encoding/decoding algorithms for
RS erasure codes. The proposed algorithms use the structure
[7] that requires evaluating a polynomial and itâ€™s derivatives,
while the polynomial used in the structure is in the new
polynomial basis, rather than the monomial basis.
The rest of this paper is organized as follows. The proposed
polynomial basis is defined in Section II. Section III gives the
definition and algorithm of the transform to compute the polynomial evaluations based on the proposed polynomial basis.
Section IV shows the formal derivative of polynomial. Section
V presents the encoding and erasure decoding algorithm
for Reed-Solomon codes. The discussions and comparisons
are placed in Section VI. SectionVII reviews some related
literature. Concluding remarks are provided in Section VIII.

Abstractâ€”In this paper, we present a new basis of polynomial
over finite fields of characteristic two and then apply it to the
encoding/decoding of Reed-Solomon erasure codes. The proposed
polynomial basis allows that h-point polynomial evaluation can
be computed in O(h log2 (h)) finite field operations with small
leading constant. As compared with the canonical polynomial
basis, the proposed basis improves the arithmetic complexity
of addition, multiplication, and the determination of polynomial
degree from O(h log2 (h) log2 log2 (h)) to O(h log2 (h)). Based on
this basis, we then develop the encoding and erasure decoding
algorithms for the (n = 2r , k) Reed-Solomon codes. Thanks to
the efficiency of transform based on the polynomial basis, the
encoding can be completed in O(n log2 (k)) finite field operations,
and the erasure decoding in O(n log2 (n)) finite field operations.
To the best of our knowledge, this is the first approach supporting
Reed-Solomon erasure codes over characteristic-2 finite fields
while achieving a complexity of O(n log2 (n)), in both additive
and multiplicative complexities. As the complexity leading factor
is small, the algorithms are advantageous in practical applications.

I. I NTRODUCTION
For a positive integer r â‰¥ 1, let F2r denote a characteristic2 finite field containing 2r elements. A polynomial over F2r
is defined as
a(x) = a0 + a1 x + a2 x2 + Â· Â· Â· + ahâˆ’1 xhâˆ’1 ,
where each ai âˆˆ F2r . A fundamental issue is to reduce
the computational complexities of arithmetic operations over
polynomials. Many fast polynomial-related algorithms, such
as Reed-Solomon codes, are based on fast Fourier transforms (FFT). However, it is algorithmically harder as the
traditional fast Fourier transform (FFT) cannot be applied
directly over a characteristic-2 finite fields. To the best of
our knowledge, no existing algorithm for characteristic-2 finite
field FFT/polynomial multiplication has provably achieved
O(h lg(h)) operations1 (see Section VII for more details).
In algorithmic viewpoint, FFT is a polynomial evaluations
at a period of consecutive points, where the polynomial is in
monomial basis. This viewpoint gives us the ability to design
fast polynomial-related algorithms. In this paper, we present a
r
new polynomial basis in the polynomial ring F2r [x]/(x2 âˆ’x).
Then a transform in the new basis is defined to compute

II. A NEW POLYNOMIAL BASIS OVER F2r
A. Finite field arithmetic
Let F2r be an extension finite field with dimension r over
r
F2 . The elements of F2r are represented as a set {Ï‰i }2i=0âˆ’1 .
We order those elements as follows. Assume that V be the rdimensional vector space spanned by v0 , v1 , . . . , vrâˆ’1 âˆˆ F2r
over F2 . For any 0 â‰¤ i < 2r , its binary representation is given

1 Throughout this paper, the notation lg(x) represents the logarithm to the
base 2.

1

III. FAST TRANSFORM Î¨lh [â€¢]

as

In this section, we define a h-point transformation Î¨lh [â€¢]
that computes the evaluations of [â€¢](x) at h successive points,
for h a power of two. Given a h-element input vector Dh ,
the polynomial [Dh ](x) can be constructed accordingly. The
transform outputs a h-element vector

i = i0 + i1 Â· 2 + i2 Â· 22 + Â· Â· Â· + irâˆ’1 Â· 2râˆ’1 , âˆ€ij âˆˆ {0, 1}. (1)
Then Ï‰i is defined as
Ï‰i = i0 Â· v0 + i1 Â· v1 + i2 Â· v2 + Â· Â· Â· + irâˆ’1 Â· vrâˆ’1 .
A polynomial f (x) defined over F2r is a polynomial whose
coefficients are from F2r .

DÌ‚hl = Î¨lh [Dh ],
where

B. Subspace vanishing polynomial

DÌ‚hl = ([Dh ](Ï‰0 + Ï‰l ), [Dh ](Ï‰1 + Ï‰l ), . . . , [Dh ](Ï‰hâˆ’1 + Ï‰l )),

The subspace vanishing polynomial defined in [8â€“10] is
expressed as
j
2Y
âˆ’1
Wj (x) =
(x + Ï‰i ),
(2)

and l denotes the amount of shift in the transform.
Oppositely, the inversion, denoted as (Î¨lh )âˆ’1 [â€¢], can convert
l
DÌ‚h into Dh , and we have (Î¨lh )âˆ’1 [DÌ‚hl ] = Dh . Here, we omit
to provide the close form for inversion. Instead, an algorithm
for transform Î¨lh [â€¢] and the inverse algorithm will be presented
later.

i=0

where 0 â‰¤ j â‰¤ r âˆ’ 1. It can be seen that deg(Wj (x)) = 2j .
Next we present properties of Wj (x) without proof.
Lemma 1 ([9]). Wj (x) is an F2 -linearlized polynomial for
which
j
X
i
Wj (x) =
aj,i x2 ,
(3)

A. Recursive structure in polynomial basis
This subsection shows that the polynomial [Dh ](x) can be
formulated as a recursive function [Dh ](x) = âˆ†00 (x), where
the function âˆ†m
i (x) is defined as

i=0

where each aj,i âˆˆ F2r is a constant. Furthermore,
Wj (x + y) = Wj (x) + Wj (y), âˆ€x, y âˆˆ F2r .

Wi (x) m+2i
âˆ†
(x)
Wi (Ï‰2i ) i+1
, for 0 â‰¤ i â‰¤ lg(h) âˆ’ 1;

m
âˆ†m
i (x) = âˆ†i+1 (x) +

(4)

C. Polynomial basis

âˆ†m
lg(h) (x) = dm , for 0 â‰¤ m â‰¤ h âˆ’ 1.

r

In this work, we consider the polynomial ring F2r [x]/(x2 âˆ’
x). A form of polynomial basis we work with is denoted as
X(x) = (X0 (x), X1 (x), . . . , X2r âˆ’1 (x)) over F2r . Each polynomial Xi (x) is defined as the product of subspace vanishing
polynomials. For each polynomial Xi (x), i is written in binary
representation as
i = i0 + i1 Â· 2 + Â· Â· Â· + irâˆ’1 Â· 2râˆ’1 , âˆ€ij âˆˆ {0, 1}.
The polynomial Xi (x) is then defined as
râˆ’1
Y  Wj (x) ij
,
Xi (x) =
Wj (Ï‰2j )
j=0

(10)

Note that m in âˆ†m
i (x) represents a lg(h)-bits binary integer
m = m0 + m1 Â· 2 + Â· Â· Â· + miâˆ’1 Â· 2i , âˆ€mj âˆˆ {0, 1}.

(11)

i
By induction, it can be seen that deg(âˆ†m
i (x)) â‰¤ h/2 âˆ’ 1.
For example, if h = 8, we have

(5)

[D8 ](x) =

7
X

di Xi (x)

i=0

W0 (x)
W1 (x)
W0 (x) W1 (x)
+ d2
+ d3
W0 (Ï‰1 )
W1 (Ï‰2 )
W0 (Ï‰1 ) W1 (Ï‰2 )
W2 (x)
W0 (x) W2 (x)
W1 (x) W2 (x)
+ d4
+ d5
+ d6
W2 (Ï‰4 )
W0 (Ï‰1 ) W2 (Ï‰4 )
W1 (Ï‰2 ) W2 (Ï‰4 )
W0 (x) W1 (x) W2 (x)
+ d7
W0 (Ï‰1 ) W1 (Ï‰2 ) W2 (Ï‰4 )



W2 (x)
W1 (x)
W2 (x)
= d0 + d4
+
d2 + d6
W2 (Ï‰4 )
W1 (Ï‰2 )
W2 (Ï‰4 )



W0 (x)
W2 (x)
W1 (x)
W2 (x)
+
d1 + d5
+
d3 + d7
W0 (Ï‰1 )
W2 (Ï‰4 )
W1 (Ï‰2 )
W2 (Ï‰4 )


W1 (x) 2
0
= âˆ†2 (x) +
âˆ† (x)
W1 (Ï‰2 ) 2


W0 (x)
W1 (x) 3
+
âˆ†12 (x) +
âˆ†2 (x)
W0 (Ï‰1 )
W1 (Ï‰2 )
W0 (x) 1
0
=âˆ†1 (x) +
âˆ† (x) = âˆ†00 (x).
W0 (Ï‰1 ) 1
(12)
=d0 + d1

(6)

ij

Wj (x)
for 0 â‰¤ i < 2r . Notice that Wj (Ï‰
= 1, if ij = 0. It can
)
2j
be seen that deg(Xi (x)) = i.
Then a form of polynomial expression [â€¢](x) is given as
follows.
Definition 1. A form of polynomial expression over F2r is
defined as
hâˆ’1
X
[Dh ](x) =
di Xi (x),
(7)
i=0

where
Dh = (d0 , d1 , . . . , dhâˆ’1 )

(9)

(8)
The âˆ†m
i (x) possesses the following equality that will be
utilized in the algorithm:

is an h-element vector denoting the polynomial coefficients
and h â‰¤ 2r . Consequently, deg([Dh ](x)) â‰¤ h âˆ’ 1.
2

Lemma 2.

In (17), we have
2i âˆ’1
m
âˆ†m
i (x + y) = âˆ†i (x), âˆ€y âˆˆ {Ï‰b }b=0 .

âˆ†m
i (Ï‰c + Ï‰l )

(13)

Proof: By Lemma 1, we have

=âˆ†m
i+1 (Ï‰c + Ï‰l ) +
i

âˆ’1
Wi (x + y) = Wi (x) + Wi (y) = Wi (x), âˆ€y âˆˆ {Ï‰b }2b=0
.

(14)

Wi (Ï‰c + Ï‰l ) m+2i
âˆ†i+1 (Ï‰c + Ï‰l ).
Wi (Ï‰2i )

(19)

It can be seen that âˆ†m
i+1 (Ï‰c + Ï‰l ) âˆˆ Î¨(i + 1, m, l), and
i
i (Ï‰c +Ï‰l )
âˆ†m+2
(Ï‰
+
Ï‰
)
âˆˆ
Î¨(i
+
1, m + 2i , l). The factor WW
c
l
i+1
i (Ï‰2i )
can be precomputed and stored. Hence, for each element of
the set given in (17), the calculation requires a multiplication
and an addition. Note that when Ï‰c + Ï‰l = 0, we have

The proof follows mathematical induction on i. In the base
case, we consider (9) at i = lg(h) âˆ’ 1:
âˆ†m
lg(h)âˆ’1 (x)
Wlg(h)âˆ’1 (x)
m+2lg(h)âˆ’1
âˆ†lg(h)
(x)
Wlg(h)âˆ’1 (Ï‰2lg(h)âˆ’1 )
Wlg(h)âˆ’1 (x)
=dm +
d
lg(h)âˆ’1 .
Wlg(h)âˆ’1 (Ï‰2lg(h)âˆ’1 ) m+2

m
âˆ†m
i (0) = âˆ†i+1 (0),

=âˆ†m
lg(h) (x) +

(20)

which does not involve any arithmetic operations.
Next we consider the computation in (18), and we have
m
âˆ†m
i (Ï‰c + Ï‰l + Ï‰2i ) = âˆ†i+1 (Ï‰c + Ï‰l + Ï‰2i )
Wi (Ï‰c + Ï‰l + Ï‰2i ) m+2i
+
âˆ†i+1 (Ï‰c + Ï‰l + Ï‰2i ).
Wi (Ï‰2i )

From (14), we have
âˆ†m
lg(h)âˆ’1 (x + y)
Wlg(h)âˆ’1 (x + y)
d
=dm +
lg(h)âˆ’1
Wlg(h)âˆ’1 (Ï‰2lg(h)âˆ’1 ) m+2
Wlg(h)âˆ’1 (x)
=dm +
d
lg(h)âˆ’1
Wlg(h)âˆ’1 (Ï‰2lg(h)âˆ’1 ) m+2

(21)

By Lemma 2, we have
m
âˆ†m
i+1 (Ï‰c + Ï‰l + Ï‰2i ) = âˆ†i+1 (Ï‰c + Ï‰l );
i

i

m+2
âˆ†m+2
i+1 (Ï‰c + Ï‰l + Ï‰2i ) = âˆ†i+1 (Ï‰c + Ï‰l ).

h/2âˆ’1
=âˆ†m
lg(h)âˆ’1 (x), âˆ€y âˆˆ {Ï‰b }b=0 .

Furthermore, the factor can be rewritten as

Thus (13) holds for i = lg(h) âˆ’ 1.
Assume (13) holds for i = c + 1. When i = c, we have

Wi (Ï‰c + Ï‰l + Ï‰2i )
Wi (Ï‰2i )
Wi (Ï‰c + Ï‰l ) + Wi (Ï‰2i )
=
Wi (Ï‰2i )
Wi (Ï‰c + Ï‰l )
=
+ 1.
Wi (Ï‰2i )

âˆ†m
c (x + y)
Wc (x + y) m+2c
âˆ†
(x + y)
Wc (Ï‰2c ) c+1
Wc (x) m+2c
âˆ†
(x + y)
=âˆ†m
c+1 (x + y) +
Wc (Ï‰2c ) c+1
Wc (x) m+2c
=âˆ†m
âˆ†
(x)
c+1 (x) +
Wc (Ï‰2c ) c+1
2c âˆ’1
=âˆ†m
c (x), âˆ€y âˆˆ {Ï‰b }b=0 .

=âˆ†m
c+1 (x + y) +

With above results, (21) can be rewritten as
âˆ†m
i (Ï‰c + Ï‰l + Ï‰2i )


i
Wi (Ï‰c + Ï‰l )
m
=âˆ†i+1 (Ï‰c + Ï‰l ) +
+ 1 âˆ†m+2
i+1 (Ï‰c + Ï‰l )
Wi (Ï‰2i )
W
(Ï‰
i
c + Ï‰l ) m+2i
âˆ†i+1 (Ï‰c + Ï‰l )
=âˆ†m
i+1 (Ï‰c + Ï‰l ) +
Wi (Ï‰2i )

This completes the proof.
B. Proposed algorithm

i

Let
h/2i âˆ’1

i
Î¨(i, m, l) = {âˆ†m
i (Ï‰c + Ï‰l )|c âˆˆ {b Â· 2 }b=0

+ âˆ†m+2
i+1 (Ï‰c + Ï‰l )
}

, for 0 â‰¤ i â‰¤ lg(h) âˆ’ 1;
Î¨(lg(h), m, l) = {dm }.

i

m+2
=âˆ†m
i (Ï‰c + Ï‰l ) + âˆ†i+1 (Ï‰c + Ï‰l ).

(15)
(16)

C. Inverse transform

The objective of algorithm is to compute the values in set
Î¨(0, 0, l). In the following, we rearrange the set Î¨(i, m, l)
into two parts: Î¨(i + 1, m, l) and Î¨(i + 1, m + 2i , l), by taking
around h/2i additions and h/2i+1 multiplications.
In (15), Î¨(i, m, l) can be divided into two individual
subsets:
h/2i+1 âˆ’1

i+1
{âˆ†m
}b=0
i (Ï‰c + Ï‰l )|c âˆˆ {b Â· 2

}

The inversion is a transform converts Î¨(i, m, l) into polyhâˆ’1
nomial coefficients {dm }m=0
. The inversion can be done
through backtracking the transform algorithm. As mentioned
previously, Î¨(i, m, l) can be rearranged into two parts: Î¨(i +
1, m, l) and Î¨(i + 1, m + 2i , l). Assume the set Î¨(i, m, l) is
given, we present the method to compute Î¨(i + 1, m, l) and
Î¨(i + 1, m + 2i , l), respectively.
To construct Î¨(i + 1, m + 2i , l), (22) is reformulated as

(17)

and
h/2i+1 âˆ’1

i+1
{âˆ†m
}b=0
i (Ï‰c + Ï‰l + Ï‰2i )|c âˆˆ {b Â· 2

}.

(22)

Hence, the element requires an addition.

i

m
m
âˆ†m+2
i+1 (Ï‰c + Ï‰l ) = âˆ†i (Ï‰c + Ï‰l ) + âˆ†i (Ï‰c + Ï‰l + Ï‰2i ). (23)

(18)
3

m
Since âˆ†m
i (Ï‰c + Ï‰l ), âˆ†i (Ï‰c + Ï‰l + Ï‰2i ) âˆˆ Î¨(i, m, l), each
m+2i
âˆ†i+1 (Ï‰c + Ï‰l ) âˆˆ Î¨(i + 1, m + 2i , l) can be calculated with
taking an addition.
To construct Î¨(i + 1, m, l), (19) is reformulated as

D8[0]

ð·8ð‘™ [1]

D8[1]
ð‘Š1ð‘™

ð‘Š2ð‘™

âˆ†m
i+1 (Ï‰c + Ï‰l )
=âˆ†m
i (Ï‰c + Ï‰l ) +

ð·8ð‘™ [0]

ð‘Š0ð‘™

ð‘Š1ð‘™

ð‘Š2ð‘™

ð·8ð‘™ [2]

D8[2]

Wi (Ï‰c + Ï‰l ) m+2i
âˆ†i+1 (Ï‰c + Ï‰l ).
Wi (Ï‰2i )

ð‘Š02âŠ•ð‘™

ð‘Š2ð‘™

(24)

ð·8ð‘™ [3]

D8[3]
ð‘Š2ð‘™

i

m+2
Since âˆ†m
i (Ï‰c +Ï‰l ) âˆˆ Î¨(i, m, l) and âˆ†i+1 (Ï‰c +Ï‰l ) âˆˆ Î¨(i+
i
m
1, m + 2 , l) are known, each âˆ†i+1 (Ï‰c + Ï‰l ) âˆˆ Î¨(i + 1, m, l)
can be calculated with taking an addition and a multiplication.
Figure 1 depicts an example of the proposed transform
Î¨lh [â€¢] of length h = 8. Figure 1(a) shows the flow graph of
the transform. The dotted line arrow denotes that the element
should be multiplied with a scalar factor WÌ‚ij upon adding
together with other element, where the scalar factor is denoted
as
Wi (Ï‰j )
.
WÌ‚ij =
Wi (Ï‰2i )
Figure 1(b) shows the flow graph of inversion. Also, it would
be of interest to compare Figure 1 with the butterfly diagram
of radix-2 FFT.

D8[4]

ð·8ð‘™ [4]

ð‘Š04âŠ•ð‘™

ð‘Š14âŠ•ð‘™

ð·8ð‘™ [5]

D8[5]
ð‘Š14âŠ•ð‘™

ð·8ð‘™ [6]

D8[6]
ð‘Š06âŠ•ð‘™

ð·8ð‘™ [7]

D8[7]

(a) The transform.
ð·8ð‘™ [0]

D8[0]
ð‘Š0ð‘™

ð‘Š1ð‘™

ð·8ð‘™ [1]

D8[1]
ð‘Š1ð‘™

ð·8ð‘™ [2]

D. Computational complexity
Clearly, the proposed transform and its inversion have
the same computational complexity. Thus, we only consider
the computational complexity on transform. By the recursive
structure, the number of arithmetic operations can be formulated as recursive functions. Let A(h) and M (h) respectively
denote the number of additions and multiplications used in the
algorithm. By (19) and (22), the recursive formula is given by

ð‘Š2ð‘™

ð‘Š2ð‘™

D8[2]
ð‘Š02âŠ•ð‘™

ð‘Š2ð‘™

ð·8ð‘™ [3]

D8[3]
ð‘Š2ð‘™

ð·8ð‘™ [4]

D8[4]
ð‘Š14âŠ•ð‘™

ð‘Š04âŠ•ð‘™

ð·8ð‘™ [5]

D8[5]
ð‘Š14âŠ•ð‘™

ð·8ð‘™ [6]

D8[6]
ð‘Š06âŠ•ð‘™

ð·8ð‘™ [7]

A(h) = 2A(h/2) + h; A(1) = 0;

D8[7]

M (h) = 2M (h/2) + h/2; M (1) = 0.
(b) The inverse transform.
Fig. 1.

The solution is
h
lg (h).
2
Notice that when the amount of shift Ï‰l = 0, the number of
operations can be reduced slightly (see (20)). In this case, we
have
h
A0 (h) = h lg (h) âˆ’ h + 1; M0 (h) = lg (h) âˆ’ h + 1.
2
E. Space complexity
In a h-point transform, we need h units of space for the
input data and an array to store the factors used in the
computation of (17). From (19), the factors are

Data flow diagram of proposed transform of length h = 8.

A(h) = h lg (h); M (h) =

IV. F ORMAL DERIVATIVE
In this section, we consider the formal derivative over the
proposed basis. Section IV-A gives the closed form of the
formal derivative. SectionIV-B presents a computation method
that has lower multiplicative complexity than the original
approach.
A. Closed-form expression of formal derivative of [Dh ](x)
Lemma 3. The formal derivative of Wi (x) is a constant given
by

Wi (Ï‰c + Ï‰l )
Wi (Ï‰c )
Wi (Ï‰l )
h/2i+1 âˆ’1
=
+
, âˆ€c âˆˆ {bÂ·2i+1 }b=0
.
Wi (Ï‰2i )
Wi (Ï‰2i ) Wi (Ï‰2i )
As 0 â‰¤ i â‰¤ lg(h), a h-point transform requires a total of
h h
h
+ + Â·Â·Â· + = h âˆ’ 1
2
4
h
units of space to store the factors. Hence, the space complexity
is O(h).

Wi0 (x) =

i
2Y
âˆ’1

Ï‰j .

j=1

Proof: Let
C(x) = c Â· xj ,
4

(25)

where c âˆˆ F2r . Its formal derivative is defined as

0
if j is even;
C 0 (x) =
cxjâˆ’1 otherwise.

B. Computation method with lower multiplicative complexity
We present an alternative approach whose multiplicative
complexity is lower than the above approach. Define
Y
ddi = di
Wj0 ,
(31)

From Lemma 1, Wi (x) has terms in the degrees of
1, 2, 4, . . . , 2i , so the formal derivative of Wi (x) is a constant
that is the coefficient of Wi (x) at degree 1. The value is

jâˆˆIi

for 0 â‰¤ i â‰¤ h âˆ’ 1. By substituting (31) into (30), we have
i
2X
âˆ’1 Y

Ï‰j =

i
2Y
âˆ’1

Ï‰j .

0

[Dh ] (x) =

j=1

l=0 j6=l

hâˆ’1
X

Xj (x)

j=0

lâˆˆIj

This completes the proof.
Y

be
Xi (x) =

il

l=0

=

X

Wl0 (x)
Wl (Ï‰2l )

Y
j6=l

Wj (x)
Wj (Ï‰2j )

 ij

0
Wm
= Wl0

mâˆˆIj+2l

0

lâˆˆIi

[Dh ] (x) =

where
(27)

=

hâˆ’1
X

For example, if i = 13 = 20 + 22 + 23 , we have

j=0

lâˆˆIjc

hâˆ’1
X

P

(28)
From (26), the formal derivative of [Dh ](x) is given by

i=0

(29)

lâˆˆIi

We move the term Xj (x) out of the summation operator to
get
hâˆ’1
X
X
[Dh ]0 (x) =
Xj (x)
Wl0 Â· dj+2l ,
(30)

lg(h)âˆ’1

Xj (x) Q

0
mâˆˆIj Wm

(33)
.

B4 = W20 ; B5 = W00 W20 ; B6 = W10 W20 ; B7 = W00 W10 W20 .
From (31), each di , 0 â‰¤ i â‰¤ 7 is computed via

where Ijc is the complement of Ij defined as
Ijc = {i}i=0

d
lâˆˆIjc dj+2l

B0 = 1; B1 = W00 ; B2 = W10 ; B3 = W00 W10 ;

lâˆˆIjc

j=0

0
mâˆˆIj Wm

can be pre-computed and stored, and this step only requires
h multiplications. In the second step, we compute the coefficients through (33). Notice that the denominator is an element
of B. Thus, this step needs around 21 h lg(h) additions and h
multiplications.
Next we use an example to demonstrate how to obtain
[Dh ]0 (x). If h = 8 and the set B includes 8 elements defined
as

=W00 X12 (x) + W20 X9 (x) + W30 X5 (x).

Wl0 Â· Xiâˆ’2l (x),

Q

jâˆˆIi

0
X13
(x)
=W00 W2 (x)W3 (x) + W20 W0 (x)W3 (x) + W30 W0 (x)W2 (x)

X

ddj+2l

X

By the above formulas, the method of computing [Dh ]0 (x)
consists of two steps. In the first step, we compute (31). Here,
the set of factors
Y
B={
Wj0 |i = 0, 1, . . . , h âˆ’ 1}
(34)

Ii = {j|ij = 1, j = 0, 1, . . . , r âˆ’ 1}.

di

Xj (x)

j=0

and Ii is a set including all the non-zero indices in the binary
representation of i, given by

hâˆ’1
X

0
Wm
,

mâˆˆIj

l

[Dh ]0 (x) =

Y

(32) can be rewritten as

(26)

Wl0 Â· Xiâˆ’2l (x),

Q2 âˆ’1
Wl0 (x)
j=1 Ï‰j
0
=
,
Wl =
Wl (Ï‰2l )
Wl (Ï‰2l )

(32)

j+2

As

By Lemma 3, the formal derivative of Xi (x) is shown to
râˆ’1
X

Wl0 Â· ddj+2l
Q
.
0
Wm
c
mâˆˆI
l

X

ddi = di Bi .

\ Ij .

From (33), the formal derivative of [D8 ](x) is shown to be

From (30), when Wl0 given in (27) are pre-computed and
stored, each coefficient of Xj (x) requires at most lg(h) âˆ’ 1
additions and lg(h) multiplications. Thus a native way to
compute the formal derivation of [Dh ](x) requires O(h lg(h))
operations, in both additive complexity and multiplicative
complexity.

[D8 ]0 (x)
dd + dd5
dd + dd6
dd + dd2 + dd4
=X0 (x) 1
+ X1 (x) 3
+ X2 (x) 3
B0
B1
B2
d
d
d
d
d
d + d6
d
dd
+ X3 (x) 7 + X4 (x) 5
+ X5 (x) 7 + X6 (x) 7 .
B3
B4
B5
B6
5

Algorithm 1 Reed-Solomon encoding algorithm.
Input: A k-element message vector Mk over F2r .
Output: An n-element systematic codeword Fn .
1: MÌ„k = (Î¨0k )âˆ’1 [Mk ]
2: for i = 1 to (n/k âˆ’ 1) do
3:
FÌ„i = Î¨iÂ·k
k [MÌ„k ]
4: end for
5: return Fn = (Mk , FÌ„1 , FÌ„2 , . . . , FÌ„dn/keâˆ’1 ).

Algorithm 2 Framework of Reed-Solomon erasure decoding
algorithm.
Input: Received codeword FÌ„n , and the positions of erasures
E = {ei }nâˆ’kâˆ’1
.
i=0
Output: The erasures {F (j)|j âˆˆ E}.
1: Compute two sets of values Î Ì„ and Î 0 , defined in (40) and
(42).
2: From (39), compute
Î¦ = (FÌ‚ (Ï‰0 ), FÌ‚ (Ï‰1 ), . . . , FÌ‚ (Ï‰nâˆ’1 )).
3: Apply n-point fast inverse transform on Î¦ to get

V. A LGORITHMS OF R EED -S OLOMON ERASURE CODES
Based on the new polynomial basis, this section presents the
encoding and decoding algorithms for (n, k) Reed-Solomon
(RS) erasure codes over characteristic-2 fields. There are two
major approaches on the encoding of Reed-Solomon codes,
termed as polynomial evaluation approach and generator polynomial approach. In this paper, we follow the polynomial
evaluation approach, which treats the codeword symbols as
the evaluation values of a polynomial F (x) of degree less
than k. Let
Mk = (m0 , m1 , . . . , mkâˆ’1 )

Î¦Ì„n = (Î¨0n )âˆ’1 [Î¦].
4: Compute the formal derivative of Î¦Ì„n . The result is denoted

as Î¦Ì„dn .
5: Apply n-point fast transform on Î¦Ì„d
n to get
Î¦dn = Î¨0n [Î¦Ì„dn ].
6: Compute the erasures via

F (j) =

denote the vector of message, for each mi âˆˆ F2r . In the
systematic construction, F (x) is a polynomial of degree less
than k such that

Î¦dn [j]
, âˆ€j âˆˆ E.
Î 0 (j)

By the set of equations (35), F (x) can be uniquely constructed
via polynomial interpolation. Then we use this F (x) to calculate the codeword

we conclude that [MÌ„k ](x) = F (x). Thus, the parity-check
symbols can be computed by applying the proposed transform
on MÌ„k (see Lines 2-4). The parity-check symbols are obtained
in blocks with size k and there are n/k âˆ’ 1 blocks.2 For each
block, the vector FÌ„i includes k elements and each element is

Fn = (F (Ï‰0 ), F (Ï‰1 ), . . . , F (Ï‰nâˆ’1 )).

FÌ„i [j] = [MÌ„k ](Ï‰j+(iÂ·k) ) = [MÌ„k ](Ï‰j +Ï‰iÂ·k ), for 0 â‰¤ j â‰¤ kâˆ’1.

In decoding, assume the received codeword has n âˆ’ k erasures
{F (y) : y âˆˆ E}, where E denotes the set of evaluation
points of erasures. With the k un-erased symbols, F (x) can be
uniquely reconstructed via polynomial interpolation, and thus
the erasures can be computed accordingly.
In the following, we illustrate the algorithms of encoding
and erasure decoding for Reed-Solomon codes. The proposed
algorithm is for k a power of two, and n = 2r . The codes for
other k can be derived through code shortening strategy; i.e.,
appending zeros to message vector so that the length of the
vector is power of two.

In Line 5, we assemble those vectors to get the codeword
vector Fn .
In summary, the encoding algorithm requires a k-element
inversion (Î¨0k )âˆ’1 [â€¢] and (n/k âˆ’ 1) times of k-element transform Î¨ik [â€¢]. Thus, the encoding algorithm has the complexity

F (Ï‰i ) = mi , for 0 â‰¤ i â‰¤ k âˆ’ 1.

(35)

O((n/k)k lg (k)) = O(n lg (k)).
B. Erasure decoding algorithm
The decoding algorithm follows our previous work [7] that
requires evaluating a polynomial and itâ€™s derivatives. The code
proposed in [7] is based on Fermat number transforms (FNT).
In this paper, we replace the role of FNT over F2r +1 with
the proposed transform over F2r . However, since the proposed
transform is not Fourier transform, some arithmetic operations
involved in the transform should be modified accordingly.
Assume the received codeword FÌ„n has n âˆ’ k erasures. The
set of evaluation points of erasures are denoted as

A. Encoding algorithm
Algorithm 1 illustrates the pseudocode of the (n, k) RS
encoding algorithm. In Line 1, we compute the vector
MÌ„k = (mÌ„0 , mÌ„1 , . . . , mÌ„kâˆ’1 ),
which can be formed as a polynomial
[MÌ„k ](x) =

kâˆ’1
X

E = {Ï‰ei }nâˆ’kâˆ’1
.
i=0

mÌ„i Xi (x).

Let
Î (x) =

i=0

Since deg([MÌ„k ](x)) â‰¤ k âˆ’ 1 and
[MÌ„k ](Ï‰i ) = mi , for 0 â‰¤ i â‰¤ k âˆ’ 1

Y

(x + y)

yâˆˆE
2 Since k and n are both powers of 2, n is divisible by k.

(36)
6

is the formal derivative of [Î¦Ì„n ](x).
In the final stage, we need to compute the erasures via (38).
Here, the denominators in (38) are defined as a set

denote the error locator polynomial having zeros at all erased
symbols. It can be seen that Î (j) = 0, âˆ€j âˆˆ E. Define
FÌ‚ (x) = F (x)Î (x),

Î 0 = {Î 0 (j)|j âˆˆ E},

and the polynomial degree is deg(FÌ‚ (x)) = deg(F (x)) +
deg(Î (x)) â‰¤ n âˆ’ 1. The formal derivative of FÌ‚ (x) is
FÌ‚ 0 (x) = F 0 (x)Î (x) + F (x)Î 0 (x).

which can be constructed by the algorithm introduced in
Appendix. We then compute

(37)

By substituting x = j âˆˆ E into (37), we have
0

Î¦dn = Î¨0n [Î¦Ì„dn ],

0

FÌ‚ (j) = F (j)Î  (j), âˆ€j âˆˆ E.

FÌ‚ 0 (j)
, âˆ€j âˆˆ E.
Î 0 (j)

(38)

Î¦dn = (FÌ‚ 0 (Ï‰0 ), FÌ‚ 0 (Ï‰1 ), . . . , FÌ‚ 0 (Ï‰nâˆ’1 )).

Based on above formulas, the decoding procedure consists of
three major stages: First, compute the coefficients of FÌ‚ (x);
second, compute the formal derivative of FÌ‚ (x); and third,
compute the erasures by (38). The details are elaborated as
follows.
In the first stage, we need to compute the coefficients of
FÌ‚ (x). It can be shown that

0
âˆ€j âˆˆ E;
FÌ‚ (j) = F (j)Î (j) =
(39)
F (j)Î (j) otherwise.

Then the erasures can be computed through (38).
The decoding procedure is summarized in Algorithm 2.
The complexity of this algorithm is dominated by Steps
1, 3, 4 and 5, whereas Steps 2 and 6 only require O(n)
multiplications. By the proposed fast transform algorithm,
Steps 3 and 5 can be done with O(n lg (n)) additions and
O(n lg (n)) multiplications. By the method in Section IV, Step
4 requires O(n lg(n)) additions and O(n) multiplications. In
Step 1, we use the algorithm shown in Appendix, and it can
be done with O(n lg(n)) modulus operations. In summary,
the proposed decoding algorithm has the complexity of order
O(n lg (n)).

Here, we define
Î Ì„ = {Î (j)|j âˆˆ F2r \E}.

(40)

Appendix shows the algorithm of computing Î Ì„ proposed by
[11]. Since F (j), j âˆˆ F2r \E are elements of the received
vector, the result of (39) can computed with n multiplications
after Î Ì„ is obtained and is denoted as a vector

VI. D ISCUSSIONS AND COMPARISONS
A. Complexities of operations in polynomial basis
We consider some polynomial operations in this section. Table I tabulates the complexities of some polynomial
operations in the monomial basis and the proposed basis
over characteristic-2 finite fields. In particular, the polynomial addition is simple by adding the coefficients of two
polynomials. Hence, the complexity is O(h) in both basis.
For the polynomial multiplication, an algorithm with order
O(h lg(h) lg lg(h)) is proposed by [12], in 1977. To compute
[Ah ](x)Ã—[Bh ](x) in the proposed basis, the result polynomial
is computed via

Î¦ = (FÌ‚ (Ï‰0 ), FÌ‚ (Ï‰1 ), . . . , FÌ‚ (Ï‰nâˆ’1 )).
Then we compute
Î¦Ì„n = (Î¨0n )âˆ’1 [Î¦].

(41)

Here, the resulting vector Î¦Ì„n = (Ï†Ì„0 , Ï†Ì„1 , . . . , Ï†Ì„nâˆ’1 ) can be
formed as a polynomial
[Î¦Ì„n ](x) =

nâˆ’1
X

Ï†Ì„i Xi (x),

i=0

(Î¨l2h )âˆ’1 [Î¨l2h [A2h ] ? Î¨l2h [B2h ]],

where [Î¦Ì„n ](Ï‰j ) = FÌ‚ (Ï‰j ), for 0 â‰¤ j â‰¤ n âˆ’ 1. That is,
[Î¦Ì„n ](Ï‰j ) âˆ’ FÌ‚ (Ï‰j ) = 0, for 0 â‰¤ j â‰¤ n âˆ’ 1. Since the degree of
[Î¦Ì„n ](x)âˆ’ FÌ‚ (x) is at most nâˆ’1, it must be the zero polynomial
when it has n roots. Hence, we conclude [Î¦Ì„n ](x) = FÌ‚ (x).
The second stage is to compute the formal derivative of
FÌ‚ (x). Since [Î¦Ì„n ](x) is under the polynomial basis given by
Definition 1, we compute the formal derivative of [Î¦Ì„n ](x) by
the method presented in Section IV. Then we can obtain the
result vector Î¦Ì„dn = (Ï†Ì„d0 , Ï†Ì„d1 , . . . , Ï†Ì„dnâˆ’1 ), and the polynomial
[Î¦Ì„dn ](x) =

nâˆ’1
X

(43)

where the resulting vector includes the evaluations of FÌ‚ 0 (j)
for j âˆˆ F2r ; i.e., the Î¦dn is denoted as

Hence the erasures can be computed by
F (j) =

(42)

where A2h ( and B2h ) is 2h-point vector by appending zeros
to Ah ( and Bh ), and ? denotes the operation of pairwise
multiplication. Hence, the complexity is O(h lg(h)).
To determine the degree polynomial in proposed basis, we
scan the coefficients of [Dh ](x) to determine the highest
degree term dj Xj (x), dj 6= 0, and thus the complexity is
O(h lg(h)); and so does the polynomial in monomial basis.
The formal derivative in proposed basis requires O(h lg(h))
field operations shown in Section IV. In contrast, the formal
derivative in monomial basis only requires O(h) operations.

Ï†Ì„di Xi (x)

i=0

7

TABLE I
C OMPLEXITIES OF OPERATIONS IN POLYNOMIAL BASIS OVER
CHARACTERISTIC -2 FINITE FIELDS
Operations
Addition
Multiplication
Polynomial degree
Formal derivative

Monomial basis
O(h)
O(h lg(h) lg lg(h))
O(h)
O(h)

â„¦(n lg(n)) operations, in a context of a fixed coding rate k/n.
However, the major drawback of FNT is that it needs more
space to store one extra symbol in practical implementation
such that the FNT-based codes are impractical in general
applications.
On the other hand, FFTs over characteristic-2 finite fields
require higher complexities than O(n lg(n)). Table II tabulates the arithmetic complexities of FFT algorithms over
characteristic-2 finite fields. As shown in Table II, Gao and
Mateer [10] gave two versions of additive FFTs over F2r that
are most likely the most efficient FFTs by far. The first is for
arbitrary r, and the second is for r a power of two. Notably,
Wuâ€™s approach [20] has very low multiplicative complexity
O(n lglg(3/2) (n)), but the additive complexity is higher with
complexity O(n2 / lglg(8/3) (n)). This implies that when the
polynomial representation in RS codes are in monomial basis,
the complexity will fail to reach O(n lg(n)).
There exist faster encoding and erasure decoding approaches
in some non-MDS codes. Such codes, termed as fountain
codes [6], require a little more than k codeword symbols to
recover the original message. Two famous classes of fountain
codes are LT code [21] and Raptor code [22]. Due to the low
complexity, fountain codes have significant merits in many
applications. However, because of the randomly generated
generator matrices, the hardware parallelization of fountain
code is not trivial.

Proposed basis
O(h)
O(h lg(h))
O(h)
O(h lg(h))

B. Comparisons with Didierâ€™s approach
In 2009, Didier [11] present an erasure decoding algorithm
for Reed-Solomon codes based on fast Walsh-Hadamard transforms. The algorithm [11] consists of two major parts: the
first part is to compute the polynomial evaluations of error
locator polynomial, and the second part is to decompose the
Lagrange polynomial into several logical convolutions, which
are then respectively computed with fast Walsh-Hadamard
transforms. The first part requires O(n lg(n)) time, and the
second part requires O(n lg2 (n)) time, so the complexity [11]
is O(n lg2 (n)). In contrast, the proposed approach employs
the first part in [11]; in the second part, we design another
decoding structure based on the proposed basis. The proposed
transform only requires O(n lg(n)) time, so that the proposed
approach can reduce the complexity from O(n lg2 (n)) to
O(n lg(n)).
We also implement the proposed algorithm in C and run
the program on Intel core i7-950 CPU. While n = 216 ,
k/n = 1/2, the program took about 1.12 seconds to generate
a codeword, and 3.06 seconds to decode an erased codeword
on average. On the other hand, we also ran the program [11]
written by the author on the same platform. In our simulation,
the program [11] took about 52.91 seconds in both encoding
and erasure decoding under the same parameter configuration.
Thus, the proposed erasure decoding is around 17 times faster
than [11], while n = 216 .

VIII. C ONCLUDING REMARKS
Based on the proposed polynomial basis, we can compute the polynomial evaluations in the complexity of order
O(h lg(h)) with a small leading constant. This enables our
capability to encode/erasure decode (n, k) Reed-Solomon
codes over characteristic-2 finite field in O(n lg(n)) time.
As the complexity leading factor is small, the algorithms are
advantageous in practical applications. To the best of our
knowledge, this is the first approach supporting Reed-Solomon
erasure codes on characteristic-2 finite fields to achieve complexity of O(n lg(n)). In addition, all the transforms employed
in the Reed-Solomon algorithms can be easily implemented
in parallel processing. Hence, the proposed algorithms substantially facilitate practical applications. While this paper
has demonstrated the polynomial basis and operations over
characteristic-2 finite fields, it is of interest to consider the
case over fields with arbitrary characteristics.

VII. L ITERATURE REVIEW
In the original view of [1], the codeword of the RS code
is a sequence of evaluation values of a polynomial interpreted
by message. By this viewpoint, the encoding process can be
treated as an oversampling process through discrete Fourier
transform (DFT) over finite fields. Some studies [13â€“15]
indicate that, if a O(n lg(n)) finite field FFT is available,
the error-correction decoding can be reduced to O(n lg2 (n)).
An n-point radix-2 FFT butterfly diagram requires n lg(n)
additions and n2 lg(n) multiplications. This FFT butterfly
diagram can be directly applied on Fermat prime fields
F2r +1 , r âˆˆ {1, 2, 4, 8, 16}. In this case, the transform, referred
to as Fermat number transform (FNT), requires n lg(n) finite
field additions and n2 lg(n) finite field multiplications. By
employing FNT, a number of fast approaches [13, 16, 17]
had been presented to reduce the complexity of encoding and
decoding of RS codes. Some FNT-based RS erasure decoding
algorithms had been proposed [7, 18, 19] in O(n lg(n)) finite
field operations. Thus far, no existing algorithm for (n, k)
RS codes has decoding complexity achieving lower than

ACKNOWLEDGMENT
This work was supported in part by Ministry of Science
and Technology of Taiwan, under grants NSC 101-2221-E011-069-MY3, NSC 102-2221-E-001-006-MY2, and MOST
103-3113-E-110-002.
A PPENDIX
In [11], Didier present an efficient algorithm to compute
the elements in two sets (40) and (42). The method is
8

TABLE II
C OMPLEXITIES OF n- POINT FFT ALGORITHMS OVER F2r , WHERE n = 2r âˆ’ 1
Algorithm
Gao [10]
Cantor [8]
Gao [10]
Wang [23], Gathen [9]
Pollard [24]
Wu [20]
Sarwate [25]
Naive approach

Restriction
r is a power of two
r is a power of two

r is even

Additive complexity
O(n lg(n) lg lg(n))
O(n lglg(3) (n))
O(n lg2 (n))
O(n lg2 (n))
O(n3/2 )
O(n2 / lglg(8/3) (n))
O(n2 )
O(n2 )

L2r = (0, Log(Ï‰1 ), Log(Ï‰2 ), . . . , Log(Ï‰2r âˆ’1 )).

presented here for the purpose of completeness. Consider the
construction of Î 0 . The formal derivative of Î (x) is given by
X Y
Î 0 (x) =
(x + y).

The result of (48) is computed by
R2wr = FWHT2r [FWHT2r [R2r ] ? FWHT2r [L2r ]],

jâˆˆE yâˆˆE,y6=j

By substituting x = j âˆˆ E into Î 0 (x), we have
Y
Y
Î 0 (j) =
(j + y) =
(j + y)R(y) ,
yâˆˆE,y6=j

(49)

where the operation ? denotes pairwise multiplication. To
further reduce the complexity, the FWHT2r [L2r ] can be
pre-computed and stored, and thus (49) can be done with
performing two fast Walsh transforms of length 2r . We remark that all the above computation can be performed over
modulo 2r âˆ’1. After obtaining R2wr , we compute the exponent
for each element of R2wr , and this step can be done via
table lookup. In summary, the algorithm requires O(2r lg(2r ))
modulus additions, O(2r ) modulus multiplications, and O(2r )
exponentiations.

(44)

yâˆˆF2r ,y6=j

where R(x) is a function defined as

1 if y âˆˆ E;
R(y) =
0 otherwise.

Multiplicative complexity
O(n lg(n))
O(n lg(n))
O(n lg(n))
O(n lg2 (n))
O(n3/2 )
O(n lglg(3/2) (n))
O(n lg(n))
O(n2 )

(45)

Define Log(x) as the discrete logarithm function. For each
i âˆˆ Fâˆ—2r , we denote Log(i) = j iff i = Î±j , where Î± is the
primitive element of Fâˆ—2r . Then (44) can be reformulated as
]
Log(Î 0 (j)) =
R(y)Log(j + y), âˆ€j âˆˆ E.

R EFERENCES
[1] I. S. Reed and G. Solomon, â€œPolynomial codes over
certain finite fields,â€ Journal of the Society for Industrial
and Applied Mathematics, vol. 8, no. 2, pp. 300â€“304,
1960.
[2] D. A. Patterson, G. Gibson, and R. H. Katz, â€œA case for
redundant arrays of inexpensive disks (RAID),â€ SIGMOD
Rec., vol. 17, no. 3, pp. 109â€“116, Jun. 1988.
[3] A. Aliev and P. Trifonov, â€œRedundant disk encoding
via erasure decoding,â€ Jan. 2 2014, US Patent App.
13/784,000. [Online]. Available: http://www.google.com/
patents/US20140006850
[4] C. Huang, H. Simitci, Y. Xu, A. Ogus, B. Calder,
P. Gopalan, J. Li, and S. Yekhanin, â€œErasure coding
in windows azure storage,â€ in Proceedings of the 2012
USENIX Conference on Annual Technical Conference,
Boston, MA, 2012, p. 2.
[5] M. Sathiamoorthy, M. Asteris, D. Papailiopoulos, A. G.
Dimakis, R. Vadali, S. Chen, and D. Borthakur, â€œXORing
elephants: Novel erasure codes for big data,â€ Proc. VLDB
Endow., vol. 6, no. 5, pp. 325â€“336, Mar. 2013.
[6] J. W. Byers, M. Luby, M. Mitzenmacher, and A. Rege,
â€œA digital fountain approach to reliable distribution of
bulk data,â€ SIGCOMM Comput. Commun. Rev., vol. 28,
no. 4, pp. 56â€“67, Oct. 1998.
[7] S. J. Lin and W. H. Chung, â€œAn efficient (n, k) information dispersal algorithm based on Fermat number
transforms,â€ IEEE Trans. Inf. Forensics Security, vol. 8,
no. 8, pp. 1371â€“1383, 2013.

yâˆˆF2r ,y6=j

U
Note that the symbol
means the summation with normal
additions. By setting Log(0) = 0, the above equation can be
rewritten as
]
Log(Î 0 (j)) =
R(y)Log(j + y), âˆ€j âˆˆ E.
(46)
yâˆˆF2r

Upon describing the algorithm to compute (46), we consider
the construction of another set Î . In the same way, the
elements of Î  can be formulated as
]
Log(Î (j)) =
R(y)Log(j + y), âˆ€j âˆˆ F2r \ E. (47)
yâˆˆF2r

With combining (46) and (47), the objective of algorithm is
to compute
]
Log(Î (j)) =
R(y)Log(j + y), âˆ€j âˆˆ F2r .
(48)
yâˆˆF2r

In (48), the operation + is the F2r addition, that can be treated
as exclusive-or operation. Hence, (48) is namely the logical
convolution [26][27], that can be efficiently computed with fast
Walsh-Hadamard transform [28]. The algorithm is elaborated
as follows.
Let F W Th [â€¢] denote the h-point fast Walsh-Hadamard
transform (FWHT). A h-point FWHT requires h lg(h) additions. Define
R2r = (R(0), R(1), . . . , R(2r âˆ’ 1)),
9

[8] D. G. Cantor, â€œOn arithmetical algorithms over finite
fields,â€ Journal of Combinatorial Theory, Series A,
vol. 50, no. 2, pp. 285â€“300, 1989.
[9] J. von zur Gathen and J. Gerhard, â€œArithmetic and
factorization of polynomial over F2 (extended abstract),â€
in Proceedings of the 1996 International Symposium on
Symbolic and Algebraic Computation, Zurich, Switzerland, 1996, pp. 1â€“9.
[10] S. Gao and T. Mateer, â€œAdditive fast Fourier transforms
over finite fields,â€ IEEE Trans. Inf. Theory, vol. 56,
no. 12, pp. 6265â€“6272, Dec 2010.
[11] F. Didier, â€œEfficient erasure decoding of Reed-Solomon
codes,â€ CoRR, vol. abs/0901.1886, 2009.
[12] A. SchoÌˆnhage, â€œSchnelle multiplikation von polynomen
uÌˆber koÌˆrpern der charakteristik 2,â€ Acta Informatica,
vol. 7, no. 4, pp. 395â€“398, 1977. [Online]. Available:
http://dx.doi.org/10.1007/BF00289470
[13] J. Justesen, â€œOn the complexity of decoding ReedSolomon codes (corresp.),â€ IEEE Trans. Inf. Theory,
vol. 22, no. 2, pp. 237â€“238, Mar 1976.
[14] R. Blahut, â€œA recursive Berlekamp-Massey algorithm,â€
in Theory and practice of error control codes. Boston:
Addison-Wesley, 1983, ch. 11.7, pp. 336â€“340.
[15] F. MacWilliams and N. Sloane, â€œGeneralized BCH
codes,â€ in The Theory of Error-correcting Codes. Oxford: North-Holland Publishing Company, 1977, ch. 12,
pp. 332â€“369.
[16] I. S. Reed, T. K. Truong, and L. R. Welch, â€œThe fast
decoding of Reed-Solomon codes using number theoretic
transforms,â€ in The Deep Space Network 42-35, Jet
Propulsion Laboratory, Pasadena, CA, July 1976, pp. 64â€“
78.
[17] I. S. Reed, R. Scholtz, T.-K. Truong, and L. Welch, â€œThe
fast decoding of Reed-Solomon codes using Fermat theoretic transforms and continued fractions,â€ IEEE Trans.
Inf. Theory, vol. 24, no. 1, pp. 100â€“106, Jan 1978.
[18] A. Sora and J. Lacan, â€œFNT-based Reed-Solomon erasure
codes,â€ in Proceedings of the 7th IEEE Conference on
Consumer Communications and Networking Conference,
Las Vegas, Nevada, USA, 2010, pp. 466â€“470.
[19] S. J. Lin and W. H. Chung, â€œAn efficient (n, k) information dispersal algorithm for high code rate system over
Fermat fields,â€ IEEE Commun. Lett., vol. 16, no. 12, pp.
2036â€“2039, December 2012.
[20] X. Wu, Y. Wang, and Z. Yan, â€œOn algorithms and
complexities of cyclotomic fast Fourier transforms over
arbitrary finite fields,â€ IEEE Trans. Signal Process.,
vol. 60, no. 3, pp. 1149â€“1158, March 2012.
[21] M. Luby, â€œLT codes,â€ in The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002, pp.
271â€“280.
[22] A. Shokrollahi, â€œRaptor codes,â€ IEEE Trans. Inf. Theory,
vol. 52, no. 6, pp. 2551â€“2567, June 2006.
[23] Y. Wang and X. Zhu, â€œA fast algorithm for the Fourier
transform over finite fields and its VLSI implementation,â€
IEEE J. Sel. Areas Commun., vol. 6, no. 3, pp. 572â€“577,

Apr 1988.
[24] J. M. Pollard, â€œThe fast Fourier transform in a finite
field,â€ Mathematics of computation, vol. 25, no. 114, pp.
365â€“374, April 1971.
[25] D. Sarwate, â€œSemi-fast Fourier transforms over
GF(2m ).â€ IEEE Trans. Comput., vol. C-27, no. 3, pp.
283â€“285, March 1978.
[26] J. E. Gibbs and F. Pichler, â€œComments on transformation
of Fourier power spectra into Walsh power spectra,â€
IEEE Trans. Audio Electroacoust., vol. EMC-13, no. 3,
pp. 51â€“54, Aug 1971.
[27] G. Robinson, â€œLogical convolution and discrete Walsh
and Fourier power spectra,â€ IEEE Trans. Audio Electroacoust., vol. 20, no. 4, pp. 271â€“280, Oct 1972.
[28] B. Fino and V. Algazi, â€œUnified matrix treatment of the
fast Walsh-Hadamard transform,â€ IEEE Trans. Comput.,
vol. C-25, no. 11, pp. 1142â€“1146, Nov 1976.

10

