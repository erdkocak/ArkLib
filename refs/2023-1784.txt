Succinct Arguments over Towers of Binary Fields
Benjamin E. Diamond

Jim Posen

Irreducible

Irreducible

bdiamond@irreducible.com

jposen@irreducible.com

Abstract
We introduce an efficient SNARK for towers of binary fields. Adapting Brakedown (CRYPTO ’23),
we construct a multilinear polynomial commitment scheme suitable for polynomials over tiny fields,
including that with just two elements. Our commitment scheme, unlike those of previous works, treats
small-field polynomials with no embedding overhead. We further introduce binary-field adaptations of
HyperPlonk (EUROCRYPT ’23)’s product and permutation checks and of Lasso (EUROCRYPT ’24)’s
lookup. Our binary PLONKish variant captures standard hash functions—like Keccak-256 and Grøstl—
extremely efficiently. With recourse to thorough performance benchmarks, we argue that our scheme can
efficiently generate precisely those Keccak-256-proofs which critically underlie modern efforts to scale
Ethereum.

1

Introduction

Succinct noninteractive arguments of knowledge, or SNARKs, have recently surged in relevance. Though
long hindered by poor prover performance, SNARKs now plausibly stand to make blockchains more scalable,
thanks to a recent, renewed effort to make these schemes more concretely efficient.
Many modern SNARKs proceed according to a framework which compiles polynomial interactive oracle
proofs into succinct arguments of knowledge using polynomial commitment schemes. This framework’s
formalization appears in Bünz, Fisch and Szepieniec [BFS20] and Chiesa et al. [Chi+20]. That latter work—
along with several previous works, like Maller, Bowe, Kohlweiss, and Meiklejohn’s Sonic [MBKM19] and
Gabizon, Williamson, and Ciobotaru’s PlonK [GWC19], in which the polynomial IOP framework is implicit—
uses the celebrated polynomial commitment scheme of Kate, Zaverucha, and Goldberg (KZG) [KZG10],
which relies on the hardness of the discrete logarithm problem in elliptic curve groups.
Ben-Sasson et al.’s highly influential Fast Reed–Solomon IOP of Proximity (FRI) [BBHR18a] has reenergized an alternative approach—dating originally to Kilian [Kil92]—which, in contrast with that based on
elliptic curves, achieves succinct arguments with the aid of linear error-correcting codes and collision-resistant
hash functions. The most popular exemplar of this latter approach is the Scalable Transparent Arguments
of Knowledge (STARK) protocol of Ben-Sasson, Bentov, Horesh, and Riabzev [BBHR18b]. Subsequent
expositions of this line of work have reinterpreted STARKs in the polynomial IOP framework discussed
above (see for example Haböck [Hab22]); in this light, we freely refer henceforth to the FRI polynomial
commitment scheme (FRI-PCS).
FRI-PCS is not the sole polynomial commitment scheme that leverages linear codes and hash functions.
Golovnev et al.’s Brakedown polynomial commitment scheme [Gol+23], which distills ideas from Bootle,
Chiesa, and Groth [BCG20] and Ames, Hazay, Ishai, and Venkitasubramaniam [AHIV23], also uses linear
error-correcting codes, and operates within the IOP model. Asymptotically, Brakedown’s verifier complexity
and proof size both grow on the order of the square root of the size of the polynomial being evaluated. (We use
terminology somewhat permissively in this work, by classifying as “SNARKs” those protocols whose verifiers
scale merely sublinearly, as opposed to strictly polylogarithmically, in their witness sizes.) Diamond and
Posen [DP24] improve the concrete efficiency of Brakedown by a factor of roughly two. While Brakedown’s
asymptotic verifier complexity is inferior to FRI’s, in many settings of practical interest, the concrete extent
of this inferiority is mild, so that Brakedown’s highly efficient prover makes it a practical alternative.

1

Recursive proof composition stands to further mitigate the impact of Brakedown’s less-efficient verifier.
Instead of proving an entire statement or virtual machine execution in a single SNARK, one can often
split up the statement in such a manner that it may be verified incrementally. Valiant [Val08] shows that
incrementally verifiable computation can be realized through recursive SNARK composition, so that a long
virtual machine execution, say, might be proven with recourse just to SNARKs for circuits of bounded size.
By composing a series of inner SNARKs with large proof sizes but fast proving times with an outer SNARK
with a small proof and a relatively slower proving time, one might obtain a hybrid system that features both
a small proof and a fast proving time.
Three major factors account for the performance advantage enjoyed by FRI-PCS and Brakedown-based
SNARKs over those based on elliptic curve assumptions.
• Small fields. Elliptic curve groups must be large—on the order of 256 bits—to attain standard security
levels. The ethSTARK [Sta21] and Plonky2 [Pol22] systems pioneer an alternative design, characterized
by the use of smaller fields (specifically, of prime fields on the order of 64 bits). By leveraging the
relative efficiency of small-field arithmetic, these systems achieve state-of-the-art proving performance.
Moreover, these protocols’ use only of small-field elements reduces their storage requirements, which
in turn leads to better cache-efficiency on CPUs.
• Structured fields. These schemes tend to use fields that are not just small, but also computationally
structured. Plonky2 [Pol22], for example, highlights the Goldilocks field Fp , where p = 264 − 232 + 1.
This prime modulus is a Solinas prime—that is, a prime of the form ϕ2 −ϕ+1, where here ϕ = 232 —and
so admits an especially efficient modular reduction algorithm.
• Efficient primitives. Standard-issue collision-resistant hash functions are much faster than elliptic
curve primitives.
As a rough comparison, the FRI-PCS scheme parameterized with Goldilocks and Keccak-256 commits
1 MiB of data about 7-fold faster than does KZG [KZG10] over the BN254 bilinear group. We note that
polynomial commitment accounts for the bulk of the prover’s cost in most SNARKs.
In view of the performance gains that smaller finite fields stand to unlock, in this work, we extend this
trend to its logical conclusion: SNARKs over the smallest field, F2 .
Binary fields. Finite fields of characteristic 2, or binary fields, have a rich history in cryptography. The
AES block cipher and the GMAC message authentication code, standardized for use alongside AES, famously
use the binary fields F28 and F2128 , respectively. A further important line of research pertains to cryptographically secure elliptic curves over binary fields; these curves feature highly efficient circuit instantiations.
We recall some basic properties of binary fields that account for their applicability in cryptography. The
elements of the field F2k can be unambiguously represented as k-bit strings; for example, there is a bijection
between the set of bytes of data and the finite field F28 . Field addition corresponds to the logical exclusive
or (XOR) operation on these bit representations. Also, squaring elements of a binary field is significantly
less expensive than multiplying two distinct elements is, thanks to the fact that (x + y)2 = x2 + y 2 for each
pair of elements x and y in these fields (an identity sometimes called the “freshman’s dream”).
In this work, we present a SNARK construction over the field F2 which competes favorably with stateof-the-art systems built with prime fields. Moreover, we argue that when proving computations that depend
heavily on bitwise operations, such as the SHA-256 and Keccak-256 hash functions, our system outperforms its prime field-based peers. We acknowledge that our work is not the first to consider SNARKs over
characteristic-2 fields; it is the first we are aware of, however, which delivers an implementation-oriented
SNARK construction over F2 specifically, and which moreover avoids embedding overhead, a phenomenon we
now explain. While [BBHR18b] develops a STARK construction over characteristic-2 fields, the naı̈ve use of
small field techniques cannot deliver superior concrete efficiency over F2 , for a simple reason: the alphabet
of each Reed–Solomon code must be at least as large as its block length. Separately from this limitation,
which pertains to the FRI IOP of proximity, the ALI protocol in STARK—as well as the DEEP-ALI protocol of the successor work Ben-Sasson, Goldberg, Kopparty, and Saraf [BGKS19]—uses fast polynomial
multiplication techniques. Fast multiplication techniques for polynomials over F2 embed those polynomials’
F2 -coefficients into an extension field, and so mandate the use of a field at least as large as the witness.
2

An influential line of recent works—which includes Spartan [Set20], HyperPlonk [CBBZ23], and CCS
[STW23]—raises the prospect of overcoming these limitations. These works develop SNARKs that bypass polynomial multiplication; instead, they leverage the classical multivariate sumcheck protocol of Lund,
Fortnow, Karloff, and Nisan [LFKN92], developed further in key work of Goldwasser, Kalai and Rothblum
[GKR15]. These protocols use multilinear polynomial IOPs and multilinear polynomial commitment schemes,
as opposed to these objects’ univariate analogues. Equipped with the polynomial commitment schemes of
[Gol+23] and [DP24]—which do not mandate the use of Reed–Solomon codes, and in fact work for general
linear codes—the multilinear regime stands to deliver efficient SNARKs over F2 with no embedding overhead.
While Reed–Solomon codes represent far from the only available choice, they nonetheless remain attractive. They are efficiently encodable and maximum-distance separable, and, moreover, admit a proximity-gap
result—due to Ben-Sasson et al. [Ben+23]—which strengthens the best-available analogues currently known
for general linear codes.
We propose two concrete polynomial commitment schemes over F2 , both based on Brakedown. We recall
that Brakedown works roughly by shaping its input polynomial’s coefficients into a two-dimensional matrix,
encoding it row-wise, and then randomly testing the resulting matrix’s columns for proximity to the code and
for consistency with prover-supplied messages. One candidate F2 -multilinear polynomial commitment would
opt to instantiate Brakedown with a concatenated code, itself constructed using a Reed–Solomon outer code
and an ad-hoc inner code (that inner code’s message and block lengths are so small that it can be selected
using ad-hoc techniques). Targeting prover efficiency and implementation simplicity, we propose a second
option, which—in virtue of a technique we call block-level encoding—allows us to use Reed–Solomon codes
simpliciter. Our second scheme draws inspiration from the concatenated code-based approach, but simplifies
that approach by omitting its inner code. The idea is to pack the elements of each message into extension
field elements, to encode each resulting message using a Reed–Solomon code, and finally to randomly sample
and test blocks of contiguous columns from the encoded matrix—which themselves correspond to Reed–
Solomon symbols in the extension field—as opposed to sampling and testing individual columns. Though
this approach yields slightly larger proofs than the concatenated code-based method does, its implementation
advantages compensate for that shortcoming.
Using this technique, our protocol attains the remarkable property whereby its commitment phase imposes
zero embedding overhead. That is, the cost of committing an ℓ-variate multilinear polynomial t(X0 , ..., Xℓ−1 )
over F2 is nearly identical under our scheme—i.e., aside from small data transposes—to that of committing
an ℓ − κ-variate polynomial t′ (X0 , . . . , Xℓ−κ−1 ) over the extension field F22κ (which contains the same
quantity of information). On the other hand, t(X0 , ..., Xℓ−1 )’s evaluation proofs are still more expensive
than t′ (X0 , . . . , Xℓ−κ−1 )’s are, for both the prover and the verifier. Finally, the sumcheck protocol also runs
less efficiently on t(X0 , ..., Xℓ−1 ) than it does on t′ (X0 , . . . , Xℓ−κ−1 ), a consequence of the fact that that
protocol draws its challenges from a cryptographically-sized extension field (like F2128 ). This latter issue is
remediated in part by certain optimizations to the sumcheck protocol available only in the small-field setting,
which we discuss in Subsection 4.2.
For these reasons, we decline to end our investigation of binary SNARKs at F2 . Rather, we push this
approach further, by using a full tower of extensions over F2 , of the form F2 ⊂ F22 ⊂ F24 ⊂ F28 ⊂ · · · ⊂ F2128 .
In this way, we introduce a new sort of flexibility into our scheme’s arithmetization procedure, whereby it
may use finite fields that appropriately capture the respective data types that the high-level program it is
arithmetizing uses.
One key illustration of the utility of tower fields at the constraint system level appears in connection
with the hash function Grøstl [Gau+11]. Grøstl has undergone extensive cryptanalysis and was a finalist
candidate in the SHA-3 competition. The hash function’s design is based on AES’s and uses the same
Rijndael S-box as AES does. Like AES, Grøstl is, in a sense, natively defined over F28 , and so admits an
efficient arithmetization in any constraint system that features native F28 -operations. We believe that this
fact makes Grøstl an attractive candidate hash function for our SNARK system. This observation resembles
one made by Ben-Sasson, Bentov, Horesh, and Riabzev [BBHR18b, § E], who note that hash functions based
on the Rijndael-160 cipher possess simple arithmetic descriptions. Accordingly, we expect to encounter low
recursion overheads in those SNARKs that use this work’s techniques and are instantiated with Grøstl. This
fact marks a notable benefit over prime field-based SNARKs, which rely, for the sake of efficient recursive
verification, on more recent—and less battle-tested—arithmetization-optimized hash functions like Poseidon
[Gra+19].

3

Our use of binary towers serves us beyond the arithmetization layer. In Subsection 2.3 below, we resurface an explicit, iterated tower construction due to Wiedemann [Wie88]. That tower boasts remarkable
computational advantages, as Fan and Paar [FP97] first noticed. In Wiedemann’s tower level F2k , multiplication, and even inversion, can be carried out with asymptotic complexity just O(k log2 3 ), a consequence
of Karatsuba-based techniques. The multiplication of field elements with subfield elements has still better
computational complexity, as we explain in Subsection 2.3. Chen et al. [Che+18] have exploited precisely
this property of tower fields to improve the performance of polynomial multiplication in binary fields. In our
performance evaluation in Section 6 below, we discuss the implications of the recently introduced Intel Galois
Field New Instructions (GFNI) instruction set extension on software implementations of Wiedemann’s tower
that target capable processors.

1.1

Our Contributions

We summarize our contributions in this work as follows.
1. A formal definition of small-field polynomial commitment schemes. While small field techniques appear in several existing SNARKs—such as Plonky2 [Pol22] and RISC Zero [BGR23]—the
security of these schemes depends on a certain undocumented soundness property, whereby the committed polynomial’s coefficients actually reside in the required ground field, as opposed to in the
extension field from which the polynomial’s evaluation query is drawn. (See Definition 3.3.)
2. A proof that [DP24] achieves a small-field polynomial commitment scheme. We prove that
the construction [DP24, Cons. 3]—with appropriate minor modifications—actually yields a small-field
scheme in the strong sense outlined above, and so provides “better-than-advertised” security. (See
Theorem 3.13.)
3. A generalization of [DP24] which uses block-level testing. Our construction yields an efficient
small-field polynomial commitment scheme for F2 -polynomials which uses Reed–Solomon codes alone,
and which encounters zero embedding overhead during its commitment phase. (See Subsection 3.4.)
4. An efficient shift argument for polynomials over the boolean hypercube. We define an operator which, on input a multivariate polynomial t, yields a multilinear polynomial whose values on the
cube are exactly t’s, but circularly rotated by an arbitrary amount of steps. Our construction answers
an open problem posed by HyperPlonk (see [CBBZ23, p. 52] of the full version). (See Subsection 4.3.)
5. An adaptation of the Lasso lookup argument [STW24] to the binary tower setting. Setty,
Thaler and Wahby’s Lasso [STW24] differs from prior lookup arguments—including that given in
HyperPlonk [CBBZ23, § 3.7]—in that it explicitly exploits the relative cheapness of committing to
small-valued elements. While the authors of [STW24] highlight this benefit only in the setting of elliptic
curve-based polynomial commitments, we show how to capture it moreover in our tower setting. (See
Subsection 4.4.)
6. An adaptation of PLONKish to the binary tower setting, and a SNARK for it. We adapt
the PLONKish arithmetization relation of HyperPlonk [CBBZ23, Def. 4.1] to our setting, enriching it
in various ways (we introduce a constraint system defined over a tower of fields, as opposed to just
one). (See Subsection 5.1.)
7. An arithmetization of the Keccak-f [1600] permutation. This permutation resides at the core of
the Keccak-256 hash function enshrined in the Ethereum protocol, and represents a key a bottleneck
facing attempts to prove statements about the Ethereum blockchain. (See Subsection 5.4.)
8. A performance evaluation of field arithmetic, our polynomial commitment scheme, and
the sumcheck protocol, all in the tower setting. We moreover compare our software implementation to those of state-of-the-art prime field SNARKs. Our multilinear polynomial commitment scheme
can commit a 228 -coefficient F2 -polynomial about 30-fold faster than can Plonky3’s Baby Bear-based
implementation of FRI-PCS, and about 40-fold faster than Hyrax [Wah+18]. (See Section 6.)

4

1.2

Prior Works

We discuss various relevant previous works. We have already mentioned above the ethSTARK [Sta21] and
Plonky2 [Pol22] systems, which introduce the use of 64-bit prime fields (and extensions thereof). The ALI
[BBHR18b] and DEEP-ALI [BGKS19] protocols—also discussed above—appear to work even over binary
fields, albeit with embedding overhead.
The ECFFT sequence of works of Ben-Sasson, Carmon, Kopparty and Levit [BCKL23; BCKL22] presents
an alternative to ALI and DEEP-ALI which makes applicable DEEP-ALI’s cyclic-group-based approach in
arbitrary fields (i.e., as opposed to merely in FFT-friendly prime fields). We note that ECFFT entails a form
of embedding overhead twice as burdensome as that which DEEP-ALI imposes, as we now explain. Indeed,
for a characteristic p (say, 2) and a witness size parameter k fixed, that work [BCKL22, Prop. 1] guarantees
the existence of an acceptably sized elliptic curve E—that is, one whose group of Fq -rational points contains
an order-2k cyclic subgroup—only over a doubly large field extension of Fp , of size q ≥ Ω(22·k ). In other
words, it requires that the curve’s field of definition Fq be roughly as large as the square of the witness.
(This fact relates to the Hasse–Weil bound; we refer to the proof of [BCKL22, Cor. 1].) Moreover, the work’s
Reed–Solomon codewords (in the sense of [BCKL22, Thm. 12]) have Fq -entries, in general. We see that
messages with entries in F2 , say, stand to yield codewords that are 2 · k-fold larger than rate considerations
alone demand that they be. For this reason, we find that work unlikely to be competitive with ours.
An interesting work of Cascudo and Giunta [CG22] directly targets the use of Ligero on witnesses valued
in F2 . We briefly recall the approach of that work. Key to that work is the idea of a reverse multiplicationfriendly embedding, a notion which originates with Cascudo, Cramer, Xing and Yuan [CCXY18]. In short—
and we restrict our discussion to the case p := 2—a (k, e)2 -RMFE is a pair of F2 -linear maps φ : Fk2 → F2e
and ψ : F2e → Fk2 for which, for each pair of elements x and y of Fk2 , x ∗ y = ψ(φ(x) · φ(y)) holds (here, we
denote by ∗ componentwise multiplication, or bitwise AND). The insight of [CG22] is that RMFEs serve to
export R1CSs relations defined over F2 to related ones defined over F2e ; crucially, in this latter field, e is
sufficiently large that Ligero can be applied off-the-shelf. Specifically, that work replaces each R1CS relation
n/k
A · w ∗ B · w = C · w + b, where w ∈ Fn2 say, with a related relation defined on the image w
e := Φ(w) ∈ F2e
(here, Φ denotes the block-wise extension of φ). On the one hand, Ligero can be used to decide this latter
relation. On the other, the latter relation moreover implies the former, provided that w
e is indeed in the
image of Φ; [CG22] describes further “lincheck” protocols which serve to convince the verifier of this fact.
The first key question is how small e can be taken, relative to k. Cascudo and Giunta [CG22, § 2.2]
note, first of all, the lower bound e ≥ 2k − 1, so that a blowup of at least twofold is inevitable. On the
positive side, using sophisticated techniques, [CCXY18, Thm. 5] shows that asymptotically, e = Θ(k) can
be achieved; moreover, when p := 2, the implicit constant can be taken to be less than 5 [CCXY18, Cor. 2].
Finally, [CG22, § A.1] presents practical constructions which show that, in essentially all parameter regimes
of practical interest, e/k can be taken to be less than 4.
In any case, we find that [CG22] stands to induce a factor-of-4 blowup in the size of the statement upon
which Ligero is run, as well as to impose further computational costs associated with its linchecks. Our
work, on the other hand, adapts Ligero so as to make that work applicable “natively” to F2 -elements, and
induces no blowup. For these reasons, we find that work unlikely to compare favorably with ours.
We finally note various works which build zero-knowledge proofs specifically for the boolean circuit model
of computation, and which moreover feature asymptotically linear-time provers. Ron-Zewi and Rothblum
[RR22] and Holmgren and Rothblum [HR22] develop an interesting approach based on tensor codes and
“code switching”; their approach internally invokes a sequence of Spielman codes respectively defined over
successive extension fields of characteristic 2. A further line of work applies techniques from MPC; we refer
for example to Weng, Yang, Katz and Wang’s Wolverine [WYKW21], as well as to the survey of Baum,
Dittmer, Scholl and Wang [BDSW23]. These works, while interesting, face various limits as far as practical
usability is concerned. They feature either private-coin verifiers [WYKW21; RR22; BDSW23], linearly-sized
proofs [WYKW21; RR22; BDSW23], non-negligible soundness error [RR22], or else unspecified large constants [HR22]. We note finally that our PLONKish arithmetization (see Subsection 5.1 below) exposes a
computational model significantly richer than that made available by boolean circuits. Indeed, our arithmetization features native F22k -operations (for arbitrary k), as well as custom gates, copy constraints, and
lookups. For these reasons, our computational model can capture with much less overhead those statements
of practical interest in blockchains.

5

1.3

Technical Overview

We roughly sketch our work’s main ideas. We begin with our polynomial commitment scheme. For simplicity,
we sketch here only our scheme’s behavior on F2 -polynomials; in general, our protocol supports polynomials
over arbitrary binary fields of power-of-two degree.
Review of Brakedown. To explain our scheme, we first recall the Ligero polynomial commitment scheme
[AHIV23], as expressed by Brakedown [Gol+23], and further simplified by Diamond and Posen [DP24, § 4].
We fix an integer ℓ ≥ 0 and an ℓ-variate multilinear polynomial t(X0 , . . . , Xℓ−1 ) ∈ F2128 [X0 , . . . , Xℓ−1 ]⪯1 .
We moreover partition ℓ = ℓ0 + ℓ1 . For expository purposes, we in fact assume that ℓ is even and that
ℓ0 = ℓ1 (the real-world considerations governing this partition are subtler). Brakedown begins by writing
m0 −1
t(X0 , . . . , Xℓ−1 )’s list (t(v))v∈Bℓ of Lagrange coefficients into a square, 2ℓ0 ×2ℓ1 matrix (ti )i=0
in row-major
ℓ
ℓ
ℓ
0
1
order (we write m0 := 2 and m1 := 2 ). For each evaluation point (r0 , . . . , rℓ−1 ) ∈ F2128 , we recall the
standard vector–matrix–vector identity:


t0
iT
h N
h N
i


..
ℓ−1
ℓ0 −1
.
·
t(r0 , . . . , rℓ−1 ) =
·
(1
−
r
,
r
)
(1
−
r
,
r
)


i
i
i
i
.
i=ℓ0
i=0
tm−1
Nℓ−1
m0 −1
In light of this identity, it suffices for the verifier to obtain the row-product t′ := i=ℓ0 (1 − ri , ri ) · (ti )i=0
;
N
ℓ
−1
0
′
given this value,
√ the
 verifier may learn its desired quantity t(r0 , . . . , rℓ−1 ) = t · i=0 (1 − ri , ri ) using just
O(m0 ) = O 2ℓ further field operations. In Brakedown, the prover opts in fact to send the verifier t′
directly (it computes t′ immediately after receiving (r0 , . . . , rℓ−1 )).
m0 −1
To make this procedure secure, Brakedown must bind its prover to its matrix (ti )i=0
(that is, before
m0 −1
it sees (r0 , . . . , rℓ−1 )). To do this, Brakedown demands that its prover encode each row of (ti )i=0
using a
m0 −1
fixed, global error-correcting code. The prover finally Merkle-commits the resulting matrix, say (ui )i=0
.
Upon choosing its evaluation point (r0 , . . . , rℓ−1 ), sending it to the prover, and receiving t′ in return, the
verifier, finally, launches its testing phase. In this phase, the verifier locally encodes t′ itself, so obtaining the
codeword u′ , say. The verifier begins selecting random codeword indices j ∈ {0, . . . , n − 1}, requesting in
m0 −1
m0 −1
each instance the j th column (ui,j )i=0
of the prover’s Merkle-committed matrix (ui )i=0
. Upon obtaining
each such column—itself certified by an appropriate Merkle path—the verifier checks whether it relates
? Nℓ−1
m0 −1
as it should to its local codeword u′ ; that is, it checks whether u′j =
holds.
i=ℓ0 (1 − ri , ri ) · (ui,j )i=0
N
m
−1
ℓ−1
0
′
(By the linearity of the error-correcting code, u =
(1 − ri , ri ) · (ui )i=0 must hold if the prover is
√ i=ℓ
0
ℓ
honest.) Each such check takes roughly O(m1 ) = O 2 work for the verifier. By means of coding-theoretic
analyses, [AHIV23], [Gol+23] and [DP24, § 4] show that, if the code at hand is of constant relative distance,
then, provided that it manages to successfully run Θ(λ) checks of this form, the verifier may certify with
m0 −1
m0 −1
is interleaved-close to the code—so that (ti )i=0
, and hence t(X0 , . . . , Xℓ−1 ) too,
confidence that (ui )i=0
′
is well-defined—as well as that t is correct, so that the verifier’s
final
result
t(r0 , . . . , rℓ−1 ) also is. The total
 √ 
ℓ
work for the verifier on the order of O(m0 + λ · m1 ) = O λ · 2 .
The small-field case. We turn our attention to the small-field case; in fact, we fix a polynomial
t(X0 , . . . , Xℓ−1 ) with coefficients in F2 . We attempt to recapitulate, in this latter setting, the recipe sketched
above. The Lagrange vector (t(v))v∈Bℓ is now a vector of mere bits. We may well write these bits, as before,
into a square matrix, provided we tacitly interpret each bit as an F2128 -element (here, we use the embedding
F2 ⊂ F2128 ). If, following Brakedown’s prescription, we picked a generic error-correcting code over F2128 ,
we would impose upon our prover an extremely inefficient encoding procedure. Indeed, its messages would
1
not be general elements of the message space Fm
2128 ; rather, their symbols would reside exclusively in the
128
much-smaller subfield F2 ⊂ F2 . The “information density” of these messages would be unusually low. On
the other hand, the symbols of its resulting codewords would be general elements of F2128 . These codewords,
then, would be huge, relative to the prover’s initial messages; that is, those messages would expand, upon
being encoded, not just by a factor of ρ1 , as is typical, but moreover by a further factor of 128.
6

One preliminary remedy would opt to choose a strictly binary code—that is, a code over the alphabet
F2 —and to proceed otherwise as in Brakedown where possible. In Subsection 3.3 below, we show that
this approach can be made to work, granting some coding-theoretic effort (see Subsection 3.1). Indeed,
m0 −1
despite beginning with messages (ti )i=0
over F2 , our prover—in this Brakedown variant—would obtain a
′
row-sum t defined rather over F2128 . By which device should the verifier “encode” this latter vector, whose
symbols reside in not in the code’s alphabet, but in a vector space over that alphabet? We resolve this
matter by means of a coding-theoretic construction we call the extension code (see Definition 3.1); using
that construction, we record our first, preliminary small-field Brakedown variant (see Construction 3.7). We
moreover establish security notions appropriate for such “small-field polynomial commitment schemes” as
ours; in short, we must demand that our emulator reliably extract a polynomial defined indeed over F2 , as
opposed to over some larger field (our security definitions are given in Subsection 3.2 below).
Binary codes of constant distance and rate are inconvenient. The most well-known construction of these
objects uses concatenated codes (see e.g. Guruswami [Gur06, § 2.3]), which require that an ad-hoc “inner
code” be supplied. In Subsection 3.4 below, we explain at length our insistence on developing a construction
which supports polynomials over tiny fields and uses only standard Reed–Solomon codes.
Reed–Solomon codes over F2 itself, of course, don’t exist; those codes definitionally demand alphabets
larger than or equal to their block lengths. One could, as in the straw-man solution above, pick rather a
Reed–Solomon code whose alphabet was as small as circumstances allowed—say, F216 —and once again apply
Brakedown otherwise unchanged. This approach, however, would again induce embedding overhead, albeit
of a more moderate sort; indeed, it would entail a message-expansion factor merely 16-fold too large, as
opposed to 128-fold too large.
We present our main technical solution in Subsection 3.4 below (see specifically Construction 3.11). Our
key idea involves a certain sort of data-casting operation, which we call packing. Given its usual binary,
m0 −1
m0 × m1 matrix (ti )i=0
—with rows each of m1 = 2ℓ1 bits—our prover groups each such row’s bits into
m0 −1
1
16-bit chunks. In this way, our prover may “pretend” that its matrix (ti )i=0
were rather an m0 × m
16 matrix
over the field F216 . Our prover then proceeds as in Brakedown on this matrix, using now a Reed–Solomon
code over F216 . We note that this commitment procedure again eliminates embedding overhead.
To attach to this commitment procedure a meaningful evaluation protocol, we must overcome various
obstacles. We must first deal—as we had to above—with the verifier’s encoding of t′ . Indeed, it is simply
not clear how the verifier should encode t′ —itself a length-m1 vector, with components in F2128 —so as to
m0 −1
obtain a result u′ which relates meaningfully to the prover’s matrix (ui )i=0
. The perhaps-most-direct route
would observe simply that our packing procedure above is nothing other than that attached to Construction
3.7’s specialization to a certain concatenated code—namely, to that built out of a Reed–Solomon outer code
and a trivial inner code. On the other hand, that latter nspecialization o
would mandate that the verifier
m1
sample random bit-columns in the codeword index space 0, . . . , ρ − 1 during its testing phase. Our
construction, rather, encourages
the verifier
n
o to query and test random size-16 blocks of columns in the
m1
1
shortened index space 0, . . . , 16 · ρ − 1 ; below, we call this idea block-level testing. Fascinatingly, our
block-testing mechanism delivers smaller, sounder proofs than that based on independent bit-columns can;
we explain this counterintuitive fact in Subsection 3.5 below (see also Examples 3.15 and 3.16).
By introducing a new algebraic object—which we call the tower algebra (see Definition 3.8)—we achieve
a more conceptual, albeit technically trickier, characterization of our main Brakedown variant. The tower
algebra is an algebraic object whose elements are, essentially, bundles of 16 F2128 -elements. Its multiplicative
structure, moreover, makes the prover’s and verifier’s row-combination and encoding steps both linear (albeit
over different subfields of the algebra!). Most importantly, it captures the precisely the framework within
which our security analysis might best proceed. In Theorem 3.10 below, we record the proximity gap at the
heart of that analysis, which adapts a result of Diamond and Posen [DP24, Thm. 2].
The role of towers. Our discussion thus far has proceeded with heed just to the single base field F2 . In
applications, however, we must deal simultaneously with polynomials over multiple fields. To make these
fields interoperate, we work with towers of binary fields, which we discuss at length in Subsection 2.3. Our
tower-based approach allows us to view F2128 simultaneously as a vector space over each of its intermediate
subfields, and to efficiently multiply elements of that field by elements of its subfields.
To showcase the utility of our tower-based approach, we develop a case study. We imagine using our
7

scheme to commit to two different multilinears, both ℓ-variate, defined over F28 and F216 , respectively. In
both commitments, we use the same matrix shape configuration ℓ0 +ℓ1 = ℓ. Those polynomials’ commitment
procedures will begin by reshaping their respective Lagrange coefficient vectors into matrices of shape 2ℓ0 ×2ℓ1
(over F28 and over F216 , respectively). Finally, we imagine evaluating both committed polynomials at the
single point (r0 , . . . , rℓ−1 ) ∈ F2128 . This situation is plausible, say after a batched sumcheck.
The prover’s first step, in its two evaluation protocols, will be to tensor-expand the suffix (rℓ0 , . . . , rℓ−1 )
Nℓ−1
and to independently row-combine both of its matrices using the single tensor vector i=ℓ0 (1−ri , ri ). These
two row-combinations will involve F2128 × F28 operations and F2128 × F216 operations, respectively. In our
tower-centric setting, the prover can do both of these sorts of operations efficiently, without conversions.
That is, the prover can multiply elements of F2128 with elements of each of that field’s subfields efficiently.
8
8
The cost of each F2128 × F28 multiplication, in the tower setting, is exactly that of 128
8 = 16 F2 × F2
16
16
=
8
F
×
F
multiplications.
multiplications. The cost of each F2128 × F216 multiplication is that of 128
2
2
16
If we didn’t use towers, then there would be no way for the prover to do both of these row-combinations
efficiently (i.e. without linear-algebraic conversions). The parties could always permanently express F2128 as a
direct algebraic extension of F28 , say. This representation would make the prover’s F2128 ×F28 multiplications
efficient. Unfortunately, it would make its F2128 × F216 multiplications costly. To perform those, the prover
would have two choices. On the one hand, it could first embed each right-hand operand along some field
embedding F216 ,→ F2128 , before performing its multiplications rather in that latter field. This approach
would face the cost of these embeddings, for one, and moreover would fail to exploit fact of its righthand operands’ membership in the proper subfield F216 ⊂ F2128 . On the other hand, it could re-express
each left-hand F2128 -element in coordinates with respect to an appropriate F216 -basis of F2128 , perform its
multiplications componentwise, and then convert the results back. The resulting multiplications would be
efficient, but the conversions would be costly (quadratic in the extension degree deg(F2128 / F28 ) = 16).
A similar problem afflicts the alternative approach in which F2128 is expressed as a direct algebraic
extension of F216 . In that setting, F2128 ×F216 multiplications would become efficient. To carry out F2128 ×F28
multiplications, on the other hand, the prover would have to first embed F28 ,→ F216 , and then carry out
the resulting F2128 × F216 multiplications in the usual way. These embeddings again wouldn’t be free, for
one; moreover, the ensuing F2128 × F216 multiplications would fail to exploit their right-hand arguments’
membership in the proper subfield F28 ⊂ F216 .
Multiplying an element of F2128 with an element of one of its subfields is efficient when F2128 is expressed
as an explicit algebraic extension of that subfield. The only way to ensure this state of affairs simultaneously
for all subfields of F2128 is to use towers. In fact, this is more-or-less the definition of a tower.
In practice, we use a particular tower construction, developed mathematically by Wiedemann [Wie88]
and algorithmically by Fan and Paar [FP97]. That construction is even more efficient than general towers
are; we discuss it in Subsection 2.3.
Beyond the PCS. In Section 4, we build a toolkit for multilinear polynomials in the binary setting. In
Subsection 4.1, we define virtual polynomials, a crucial notion. A virtual polynomial is a polynomial assembled from raw, committed polynomials, which the verifier—given access to these underlying polynomials—can
evaluate efficiently. While an important special case of this notion—namely, that of composition (see Example 4.9)—is implicit in prior work, our variant allows even virtual polynomials whose evaluation procedures
are interactive (say, involving a sumcheck). This latter sort of flexibility proves essential in our Subsection
4.3, where we define various new virtual polynomials. These serve to pack and shift raw, committed polynomials. In fact, our shifting construction—itself a virtual polynomial of our more general variety—answers an
open problem posed by HyperPlonk (see Remark 4.26). In Subsection 4.4, we develop a lookup argument,
adapting Setty, Thaler and Wahby’s Lasso [STW24] to the binary setting.
In Section 5, we put the pieces together, assembling a full SNARK for binary towers. We first describe
a top-level IOP for our binary PLONKish variant (see Protocol 5.1). In Subsection 5.3, we describe various
gadgets, designed to achieve unsigned integer arithmetic operations. Our addition gadget (see Protocol 5.3)
effects a ripple-carry adder, using our shift construction internally. Our multiplication gadget (see Protocol
5.5) is still more complicated; it emulates the schoolbook algorithm on its arguments, using our lookup
protocol to effect its limb-by-limb products and our addition gadget to accumulate its internal rows. Our
gadgets stand to address the concerns of those who—citing the difficulty of unsigned integer arithmetic—have
historically deemed implausible the prospect of concretely efficient, binary-field-based SNARKs.
8

Performance and benchmarks. In Section 6, we benchmark an end-to-end, Rust implementation of
our protocol. Our benchmarks demonstrate that our protocol performs competitively against the stateof-the-art Plonky3 and Hyrax polynomial commitment schemes, especially on polynomials over tiny fields.
We moreover benchmark our scheme’s performance on our binary-native arithmetization of the Keccak-f
permutation (itself given in Subsection 5.4). On a benchmark task in which 8,192 independent Keccak-f
permutations are proved valid, our scheme outperforms Plonky3 by roughly twofold in the singlethreaded
setting and fourfold in the multithreaded setting (see Tables 5 and 6 below).
Acknowledgements. This work would not have been possible without the support of our colleagues at
Irreducible. Their perspectives and insights regarding computational efficiency, as well as the thorough
hardware prototypes they built, guided our investigation. We would like to gratefully acknowledge the
contributions of Justin Thaler to this work, which arose throughout the course of many fruitful discussions.
We would finally like to thank Eli Ben-Sasson for answering several questions pertaining to zk-STARKs over
binary fields.

2

Background and Notation

We write N for the set of nonnegative integers. For sets A and B, we write B A for the set of maps A → B.
Below, we consider only finite fields. We fix an arbitrary finite field K (we focus on the case in which K
is of characteristic 2). For each ℓ ∈ N, we write Bℓ for the ℓ-dimensional boolean hypercube {0, 1}ℓ ⊂ K ℓ .
We occasionally identify Bℓ with the integer range {0, . . . 2ℓ − 1} lexicographically. That is, we identify each
Pℓ−1
v = (v0 , . . . , vℓ−1 ) in Bℓ with the integer i=0 2i · vi ; we moreover write {v} for this latter integer.

2.1

Polynomials

We recall certain basic facts pertaining to multivariate polynomials, referring throughout to Thaler [Tha22,
§ 3.5]. We recall the ring K[X0 , . . . , Xℓ−1 ] of ℓ-variate polynomials over K. We write K[X0 , . . . , Xℓ−1 ]⪯d for
the set of ℓ-variate polynomials over K of individual degree at most d in each variable. Multilinear polynomials
are multivariate polynomials of individual degree at most 1 in each variable (see [Tha22, Def. 3.4]); the set
of all such polynomials is K[X0 , . . . , Xℓ−1 ]⪯1 . A degree-d multivariate extension of a map t ∈ K Bℓ is a
polynomial t̂ ∈ K[X0 , . . . , Xℓ−1 ]⪯d for which t̂(x) = t(x) holds for each x ∈ Bℓ .
Each map t ∈ K Bℓ admits a unique degree-1 multivariate extension t̂ ∈ K[X0 , . . . , Xℓ−1 ]⪯1 (see [Tha22,
Fact 3.5]). We thus refer freely to the degree-1 multivariate extension of t; we write e
t for this polynomial and
call it t’s multilinear extension (MLE). We recall the equality indicator function eq : Bℓ × Bℓ → K, which
?

sends (x, y) 7→ x = y, as well as its MLE, the equality indicator polynomial (see [Tha22, Lem. 3.6]):
e
fq(X0 , . . . , Xℓ−1 , Y0 , . . . , Yℓ−1 ) =

ℓ−1
Y

(1 − Xi ) · (1 − Yi ) + Xi · Yi .

i=0

For each t ∈ K Bℓ , we have the following explicit representation of t’s multilinear extension e
t ∈
K[X0 , . . . , Xℓ−1 ]⪯1 :
X
e
t(X0 , . . . , Xℓ−1 ) =
t(v) · e
fq(X0 , . . . , Xℓ−1 , v0 , . . . , vℓ−1 ).
v∈Bℓ

The proof that e
t is t’s multilinear extension is straightforward (see [Tha22, Lem. 3.6], for example).
For each fixed (r0 , . . . , rℓ−1 ) ∈ K ℓ , the vector (f
eq(r0 , . . . , rℓ−1 , v0 , . . . , vℓ−1 ))v∈Bℓ takes the form
!
ℓ−1
Y
ri · vi + (1 − ri ) · (1 − vi )
= ((1 − r0 ) · · · · · (1 − rℓ−1 ), . . . , r0 · · · · · rℓ−1 ).
i=0

v∈Bℓ

Nℓ−1
We call this vector the tensor product expansion of the point (r0 , . . . , rℓ−1 ) ∈ K ℓ , and denote it by i=0 (1 −
Nℓ−1
Nℓ−1
Nℓ−1
ri , ri ). We note the recursive description i=0 (1 − ri , ri ) = (1 − r0 ) · i=1 (1 − ri , ri ) ∥ r0 · i=1 (1 − ri , ri ).
Nℓ−1
This description yields a Θ(2ℓ )-time algorithm which computes i=0 (1 − ri , ri ) (see e.g. [Tha22, Lem. 3.8]).
9

2.2

Error-Correcting Codes

We adapt the notation of Diamond and Posen [DP24, § 2]. A code of block length n over the alphabet Σ
is a subset of Σn . In Σn , we write d for the Hamming distance between two vectors (i.e., the number of
components at which they differ). We again fix a field K. A linear [n, k, d]-code over K is a k-dimensional
linear subspace C ⊂ K n for which d(v0 , v1 ) ≥ d holds for each pair of unequal elements v0 and v1 of C.
Given a linear code C ⊂ K n and an integer m ≥ 1, we have C’s m-fold interleaved code, defined as the
m
n
subset C m ⊂ (K n ) ∼
= (K m ) . We understand this latter set as a length-n block code over the alphabet
K m . In particular, its elements are naturally identified with those matrices in K m×n each of whose rows is
m−1
a C-element. We write matrices (ui )i=0 ∈ K m×n row-wise. By definition of C m , two matrices in K m×n
m−1
differ at a column if they differ at any of that column’s components.
That a matrix (ui )i=0 ∈ K m×n is

m−1

within distance e to the code C m —in which event we write dm (ui )i=0 , C m ≤ e—thus entails precisely


m−1
that there exists a subset D := ∆m (ui )i=0 , C m , say, of {0, . . . , n − 1}, of size at most e, for which, for

each i ∈ {0, . . . , m − 1}, the row ui admits a codeword vi ∈ C for which ui |{0,...,n−1}\D = vi |{0,...,n−1}\D . We
emphasize that the subset D ⊂ {0, . . . , n − 1} is fixed, and does not vary as the row-index i ∈ {0, . . . , m − 1}
m−1
varies. In this circumstance, following the terminology of [Ben+23], we say that the vectors (ui )i=0 feature
correlated agreement outside of the set D, or that they feature e-correlated agreement. We note that the
m−1
condition whereby the vectors (ui )i=0 feature e-correlated agreement with C m implies a fortiori that every
m−1
element in (ui )i=0 ’s row-span is itself within distance at most e from C.
We recall Reed–Solomon codes. For each subset S = {s0 , .. . , sn−1 } of K and message length k ≤ n,
the Reed–Solomon code RSK,S [n, k] is defined as RSK,S [n, k] = (p(s0 ), . . . , p(sn−1 )) p(X) ∈ K[X]<k . In
words, RSK,S [n, k] is the set of n-tuples which arise as the evaluations, over the n points of S, of some
polynomial p(X) ∈ K[X] of degree less than k. Here, we identify K[X]<k with K k using the monomial
K-basis 1, X, . . . , X k−1 of K[X]<k . The code RSK,S [n, k] is of distance d = n − k + 1 (see e.g. Guruswami
[Gur06, Def. 2.3]). Lin, Chung, and Han show in recent work [LCH14] that, for K a binary field, and S ⊂ K
an appropriately chosen F2 -affine linear subspace, the encoding function of RSK,S [n, k]—or at least of a
code isomorphic to it—can be computed in Θ(n · log k) time. (The code C ⊂ K n of [LCH14] differs from
RSK,S [n, k] by precomposition with a K-isomorphism on K k , and so inherits RSK,S [n, k]’s properties in full.)

2.3

Binary Towers

We review towers of field extensions. The following explicit construction is due to Wiedemann [Wie88], and
appears also in Cohen [Coh92] and Fan and Paar [FP97], for example; we refer to Blake et al. [Bla+93,
§ 3.4] for further historical
remarks. We define a sequence of rings inductively, by setting T0 := F2 , T1 :=

2
2
F2 [X0 ] / X0 + X0 + 1 , and, for each ι > 1, Tι := Tι−1 [Xι−1 ] / Xι−1
+ Xι−2 · Xι−1 + 1 . It is shown in
2
[Wie88, Thm. 1] that, for each ι > 1, the polynomial Xι−1 + Xι−2 · Xι−1 + 1 is irreducible in Tι−1 [Xι−1 ].
We conclude by induction that, for each ι ≥ 0, the ring Tι is a field, isomorphic to F22ι .
For each ι > 0, Tι−1 arises naturally as the subfield of Tι consisting of (the equivalence classes of) constant
polynomials. Applying induction, we obtain a tower construction T0 ⊂ T1 ⊂ · · · ⊂ Tι . Moreover, for each
ι ≥ 0, we have a straightforward identification of rings:

2
Tι = F2 [X0 , . . . , Xι−1 ] / X02 + X0 + 1, . . . , Xι−1
+ Xι−2 · Xι−1 + 1 .
This identification respects the tower structure in the obvious way; indeed, Tι−1 ⊂ Tι is precisely the subring
consisting of the equivalence classes of those polynomials in which only the variables X0 , . . . , Xι−2 appear.
It holds—say, by Gröbner basis considerations—that, for each ι ≥ 0, each equivalence class in Tι has a
unique multilinear representative. We conclude that the set of monomials 1, X0 , X1 , X0 · X1 , . . . , X0 · · · · Xι−1
gives a basis of Tι as an F2 -vector space; we call this basis
Qι−1the multilinear basis. For each u ∈ Bι , with
boolean components (u0 , . . . , uι−1 ), say, we write βu := i=0 ((1 − ui ) + ui · Xi ); that is, βu is that basis
vector corresponding to the product of precisely those indeterminates among the list X0 , . . . , Xι−1 indexed
by u’s components. More generally, for each pair of integers ι ≥ 0 and κ ≥ 0, the set 1, Xι , Xι+1 , Xι ·
Xι+1 , . . . , Xι · · · · · Xι+κ−1 gives a Tι -basis of Tι+κ ; we again write (βu )u∈Bκ for this basis. That is, for each
Qκ−1
u ∈ Bκ , we write βu := i=0 ((1 − ui ) + ui · Xι+i ).
10

We briefly survey the efficiency of tower-field arithmetic. In practice, we represent all Tι -elements in
coordinates with respect to the multilinear F2 -basis, which we moreover sort in lexicographic order. In
particular, each Tι -element α admits a length-2ι coordinate vector (a0 , . . . , a2ι −1 ), with components in F2 ;
we note, in light of our lexicographic basis-ordering, that this vector’s 0th and 1st halves respectively define
Tι−1 -elements α0 and α1 for which α = α1 · Xι−1 + α0 in fact holds.
Throughout, addition amounts to bitwise XOR. We multiply Tι -elements in the following way. To multiply
the elements α1 ·Xι−1 +α0 and α1′ ·Xι−1 +α0′ of Tι , say, we first use the Karatsuba technique—that is, we use
2
three recursive multiplications in Tι−1 —to obtain the expression α1 ·α1′ ·Xι−1
+(α0 ·α1′ +α1·α0′ )·Xι−1 +α0 ·α0′ .
′
2
We then reduce this latter polynomial by subtracting α1 · α1 · Xι−1 + Xι−2 · Xι−1 + 1 from it; this step
itself entails computing the product α1 · α1′ · Xι−2 in Tι−1 .
Fan and Paar [FP97, § III] show that, in the Wiedemann tower, each such “constant multiplication”—
that is, each multiplication of a Tι -element by the constant Xι−1 —can be carried out in linear time Θ(2ι ).
In light of this fact, and using the “master theorem” for recurrence relations (see e.g. Cormen, Leiserson,
Rivest, and Stein [CLRS22,
Thm. 4.1]), we conclude that this recursive, Karatsuba-based approach features

complexity Θ 2log(3)·ι (we refer also to [FP97, § IV] for a thorough analysis).
We finally record a further key property, whereby field-elements may be multiplied by subfield-elements
especially efficiently. In slightly more detail, the complexity of multiplying a Tι -element by a Tι+κ -element
grows just linearly in the extension degree of Tι+κ over Tι . We express this precisely as follows. For
each element α ∈ Tι+κ , with coordinate representation (au )u∈Bκ with respect to the multilinear Tι -basis of
Tι+κ , say, and each scalar b ∈ Tι , the representation of b · α with respect to this basis is (b · au )u∈Bκ . We

conclude that the multiplication of a Tι+κ -element by a Tι -element can be carried out in 2κ · Θ 2log(3)·ι time.
This property—whereby elements of differently-sized fields can be efficiently multiplied—has been noted by
previous authors; we refer for example to Bernstein and Chou [BC14, § 2.4].
Comparison with classical binary fields. We contrast this work’s tower-based approach with the
classical, univariate treatment of binary fields. Informally, towers feature both efficient embeddings and
efficient small-by-large multiplications; classical binary fields lack both of these properties. We record the
details. For fι (X) ∈ F2 [X] irreducible of degree 2ι , the quotient ring F2 [X] / (fι (X)) is isomorphic to F22ι ,
ι
and admits the F2 -basis 1, X, . . . , X 2 −1 , which we call the (univariate) monomial basis. We again fix ι and
κ in N. Clearly, there exists an embedding F22ι ,→ F22ι+κ of abstract fields (in fact, we have 2ι choices,
ι
ι+κ
by Galois-theoretic considerations). Identifying these objects with F22 and F22 , respectively—by means of
ι
ι+κ
their monomial bases—we obtain a mapping F22 ,→ F22
of F2 -vector spaces. What is the bit-complexity
of this mapping? When F22ι and F22ι+κ are constructed as univariate quotients, the answer is complicated.
ι
(Informally, given a0 + · · · + a2ι −1 · X 2 −1 , how do we determine the coefficients of its image in F22ι+κ ?)
Obviously, in view of the complexity of binary matrix multiplication, we cannot do worse than O(22·ι+κ )
bit-operations. Given irreducible polynomials fι (X) and fι+κ (X) sufficiently carefully chosen, one may be
able to do better; we refer to Bosma, Cannon and Steel [BCS97] for a thorough treatment of this issue.
In our tower setting, the embedding Tι ,→ Tι+κ of fields again induces—via these fields’ respective
ι
ι+κ
multilinear bases—a mapping F22 ,→ F22
of F2 -vector spaces. This latter mapping, on the other hand, is
free! Indeed, it amounts to a trivial zero-padding operation.
A similar issue affects the multiplication of F22ι+κ -elements by F22ι -elements. Indeed, to multiply an
element α ∈ F22ι+κ by b ∈ F22ι , say (and in fact, even to give sense to this operation), we could fix a particular
embedding F22ι ,→ F22ι+κ , and multiply α by b’s image under this embedding. The cost of this operation,
however, would be—beyond that of embedding b—the same as that of a standard F22ι+κ -multiplication; in
other words, it would fail to exploit the fact that b belongs to the proper subfield F22ι ⊂ F22ι+κ . Alternatively,
we could pick an arbitrary F22ι -basis of F22ι+κ , express α = (a0 , . . . , a2κ −1 ) in coordinates with respect to this
basis, multiply α by b componentwise, and finally convert the result back, let’s say. This approach, however,
would require two conversion operations, which could each cost as many as Ω(22·κ ) (i.e., quadratically many)
F22ι -operations in the worst case. In fact, our tower approach, arguably, begins with precisely the insight
whereby, by representing F22ι+κ -elements continually in coordinates with respect to some F22ι -basis, we
might avoid these conversions.

11

A family of bases at multiple scales. To illustrate this point, we fix quantities ι and κ as above, as
well as an element α ∈ Tι+κ . Of course, α = (a0 , . . . , a2κ −1 ) admits some representation with respect to
the multilinear Tι -basis of Tι+κ ; on the other hand, both Tι and Tι+κ have their own respective multilinear
F2 -bases, so that both α and its components (a0 , . . . , a2κ −1 ) in Tι have corresponding representations as
2ι+κ -bit and 2ι -bit strings (respectively). We phrase the key compatibility property at hand as follows.
Indeed, the respective F2 -basis representations of α itself and of its components (a0 , . . . , a2κ −1 ) are related
by concatenation, so that the equality α = a0 ∥ · · · ∥ a2κ −1 of 2ι+κ -bit strings holds (here, we interpret each
symbol as a string of bits, using in each case the appropriate multilinear F2 -basis). In other words, we may
express each given α ∈ Tι+κ —given by its F2 -coordinates—in coordinates with respect to Tι+κ ’s multilinear
Tι -basis simply by splitting its coordinate representation into 2ι -bit substrings.

3

Small-Field Polynomial Commitments

In this section, we introduce small-field polynomial commitment schemes, and moreover supply several instantiations based on binary tower fields. In Subsection 3.2 below, we define the basic cryptographic abstraction.
We then instantiate this abstraction in two different ways. In Subsection 3.3 below, we outline a simple
instantiation, suitable for polynomials whose coefficient field coincides with the alphabet of an available
code. In Subsection 3.4 below, we introduce a further variant, designed to support the commitment of
polynomials over fields even smaller than the alphabet of the code selected for use. Both schemes follow the
Brakedown-inspired scheme of Diamond and Posen [DP24, § 4], with appropriate adaptations.

3.1

The Extension Code

Before proceeding, we pause to record a certain key coding-theoretic construction, which figures prominently
in what follows. Informally, given some fixed code, with symbols in a field, our construction “lifts” the
code to one with symbols in a vector space over that field. The resulting object inherits many of the same
properties—most essentially, the distance—of the original code.
Definition 3.1. We fix an [n, k, d]-code C ⊂ K n , with generator matrix M ∈ K n×k , say, and a K-vector
b ⊂ V n of C is the image of the map V k → V n which sends t 7→ M · t.
space V over K. The extension code C
b ⊂ V n simply reuses C’s generator matrix; we note that the action of a
In other words, the code C
K-matrix on a V -vector is well-defined.
b ⊂ V n isn’t, strictly speaking, a linear code; indeed, its symbols take values in V , which is
The object C
b inherits C’s distance, as the following theorem shows:
not in general a field. On the other hand, C
b ⊂ V n has distance d.
Theorem 3.2. The extension code C
Proof. We write η for the dimension of V over K, and fix a K-basis (α0 , . . . , αη−1 ) of V , as well as two
unequal messages t0 and t1 in V k . Expressing these messages’ components in coordinates with respect to
this basis, we obtain corresponding vectors t0,h and t1,h , in K k , for each index h ∈ {0, . . . , η − 1}. Our
hypothesis t0 ̸= t1 implies that, for at least one index h∗ ∈ {0, . . . , η − 1}, the slices t0,h∗ and t1,h∗ are
b generator matrix consists of K-elements, the encodings u0 := Enc(t0 )
unequal as elements of K k . Since C’s
and u1 := Enc(t1 ) of t0 and t1 are themselves given, slice-wise, by the respective encodings of the slices
η−1
η−1
(t0,h )h=0 and (t1,h )h=0 . We conclude that the slices u0,h∗ and u1,h∗ , viewed as elements of K n , differ at at
b
least d positions, and thus finally that the elements u0 and u1 of V n also do. We see that the distance of C
is at least d. Conversely, we may easily construct unequal codewords in V n of distance exactly d. Indeed,
given unequal messages t0 and t1 in K k whose encodings differ at exactly d positions, we embed both t0 and
t1 componentwise into V along the basis vector α0 . We see that the resulting messages’ encodings u0 and
u1 in V n differ at exactly d positions; indeed, their discrepancies all arise from their respective 0th -indexed
slices, since these codewords’ positive-indexed slices are all identically zero. This completes the proof.
b “dimension” over V is of course not well-defined in general; we
As V isn’t necessarily itself a field, C’s
b ⊂ V n is a V -linear [n, k, d]-code whenever V / K is a degree-η field extension.
note, however, that C

12

3.2

Definition of Small-Field Polynomial Commitment Schemes

We now define small-field polynomial commitment schemes, adapting the definitions [DP24, Defs. 1–3], which
themselves closely follow Setty [Set20, § 2.4]. Our adaptation demands that each multilinear polynomial
t(X0 , . . . , Xℓ−1 ) at hand reside in K[X0 , . . . , Xℓ−1 ], for a user-specified field K, allowed to be arbitrarily
small. On the other hand, we allow each evaluation query point (r0 , . . . , rℓ−1 ) ∈ Lℓ , as well as each claimed
evaluation result s ∈ L, to be defined over an extension L / K of K. Thus, in short, Definition 3.3 below
yields a commitment scheme for polynomials over small fields, which can nonetheless be queried at points
over large extension fields of the polynomial’s field of definition.
Definition 3.3. A small-field multilinear polynomial commitment scheme is a tuple of algorithms Π =
(Setup, Commit, Open, Prove, Verify), with the following syntax:
• params ← Π.Setup(1λ , ℓ, K). On input the security parameter λ, a size parameter ℓ, and a field K,
Π.Setup samples params, which includes (possibly among other things) a field extension L / K.
• (c, u) ← Π.Commit(params, t).
On input a multilinear polynomial t(X0 , . . . , Xℓ−1 )
K[X0 , . . . , Xℓ−1 ]⪯1 , Π.Commit returns a commitment c to t, together with an opening hint u.

∈

• b ← Π.Open(params, c; t, u). On input a commitment c, a multilinear polynomial t(X0 , . . . , Xℓ−1 ) ∈
K[X0 , . . . , Xℓ−1 ]⪯1 , and an opening hint u, Π.Open verifies the claimed decommitment t of c, using u.
• π ← Π.Prove(params, c, s, (r0 , . . . , rℓ−1 ); t, u). On input a commitment c, a purported evaluation s ∈ L,
an evaluation point (r0 , . . . , rℓ−1 ) ∈ Lℓ , a multilinear polynomial t(X0 , . . . , Xℓ−1 ) ∈ K[X0 , . . . , Xℓ−1 ]⪯1 ,
and an opening hint u, Π.Prove generates an evaluation proof π.
• b ← Π.Verify(params, c, s, (r0 , . . . , rℓ−1 ), π). On input a commitment c, a purported evaluation s, an
evaluation point (r0 , . . . , rℓ−1 ) ∈ Lℓ , and a proof π, Π.Verify outputs a success bit b ∈ {0, 1}.
We note that, for Π to be efficiently computable, it’s necessary that ℓ = O(log λ), as well as that the
sizes log(|K|) and log(|L|) grow at most polynomially in λ. We assume as much throughout what follows.
We define the security properties of binding and extractability for small-field multilinear polynomial
commitment schemes, adapting [DP24, Def. 2] and [DP24, Def. 3], respectively.
Definition 3.4. For each small-field multilinear polynomial commitment scheme Π, size parameter ℓ, input
field K, and PPT adversary A, we define the binding experiment BindingΠ,ℓ,K
(λ) as follows:
A
1. The experimenter samples params ← Π.Setup(1λ , ℓ, K), and gives params to A.
2. The adversary outputs (c, t0 , t1 , u0 , u1 ) ← A(params), where c is a commitment, t0 (X0 , . . . , Xℓ−1 ) and
t1 (X0 , . . . , Xℓ−1 ) are multilinear polynomials in K[X0 , . . . , Xℓ−1 ]⪯1 , and u0 and u1 are opening hints.


3. The output of the experiment is defined to be 1 if Π.Open params, c; t0 , u0 , Π.Open params, c; t1 , u1 ,
and t0 ̸= t1 all hold; otherwise, it is defined to be 0.
The scheme Π is said to be binding if, for each PPT adversary A, there is ahnegligible function
i negl(λ) for

which, for each security parameter λ ∈ N and each ℓ and K, it holds that Pr BindingΠ,ℓ,K
(λ) ≤ negl(λ).
A

Definition 3.5. For each small-field multilinear polynomial commitment scheme Π, security parameter λ,
values ℓ and K, PPT query sampler Q, PPT adversary A, expected PPT emulator E, and PPT distinguisher
Π,ℓ,K
D, we define two random variables RealΠ,ℓ,K
Q,A,E,D (λ) and IdealQ,A,E,D (λ), each valued in {0, 1}, as follows:
1. The experimenter samples params ← Π.Setup(1λ , ℓ, K), and gives params to A, Q and E.
2. The adversary outputs a commitment c ← A(params).
3. The query sampler outputs (r0 , . . . , rℓ−1 ) ← Q(params).
4. The experimenter proceeds in one of two separate ways:

13

• RealΠ,ℓ,K
Q,A,E,D (λ): Run (s, π) ← A(r0 , . . . , rℓ−1 ). Output the single bit D(c, s, π).
• IdealΠ,ℓ,K
Run (s, π; t, u) ← E A (r0 , . . . , rℓ−1 ). Output the single bit D(c, s, π) ∧
Q,A,E,D (λ):
(Π.Verify(params, c, s, (r0 , . . . , rℓ−1 ), π) =⇒ (Π.Open(params, c; t, u) ∧ t(r0 , . . . , rℓ−1 ) = s)).
The scheme Π is said to be extractable with respect to the query sampler Q if, for each PPT adversary
A, there isoan expectednPPT emulator o
E such that, for each PPT distinguisher D, the distributions
n
Π,ℓ,K
RealΠ,ℓ,K
(λ)
and
Ideal
(λ)
are statistically close.
Q,A,E,D
Q,A,E,D
(ℓ,K),λ

(ℓ,K),λ

We note that, critically, the polynomial t(X0 , . . . , Xℓ−1 ) extracted by E must reside in K[X0 , . . . , Xℓ−1 ],
by definition of Π.Open.
The following definition is analogous to [DP24, Def. 4].
Definition 3.6. The query sampler Q is admissible if, for each λ, ℓ and K, and each parameter set params ←
Π.Setup(1λ , ℓ, K), containing L / K, say, the evaluation point (r0 , . . . , rℓ−1 ) ← Q(params) is uniform over Lℓ .

3.3

Basic Small-Field Construction

We now give our simple small-field construction. This construction generalizes [DP24, Cons. 3] in such a way
as to make that scheme instantiate the small-field abstraction of Definition 3.3. In our generalization, we
allow the polynomial’s coefficient field and the code’s alphabet to be small, though we require that these fields
be equal to each other (cf. Subsection 3.4 below). We obtain security by the means of a cryptographically
sized field extension. Our construction closely follows [DP24, Cons. 3], making only minor modifications
throughout.
CONSTRUCTION 3.7 (Simple small-field polynomial commitment scheme).
We define Π = (Setup, Commit, Open, Prove, Verify) as follows.
• params ← Π.Setup(1λ , ℓ, K). On input 1λ , ℓ, and K, choose integers ℓ0 and ℓ1 for which ℓ0 +ℓ1 = ℓ,
and write m0 := 2ℓ0 and m1 := 2ℓ1 . Return an extension field L / K for which |L| ≥ 2ω(log λ) , an
[n, m1 , d]-code C ⊂ K n for which n = 2O(ℓ) and d = Ω(n), and a repetition parameter γ = Θ(λ).
• (c, u) ← Π.Commit(params, t). On input t(X0 , . . . , Xℓ−1 ) ∈ K[X0 , . . . , Xℓ−1 ]⪯1 , express t =
(t0 , . . . , t2ℓ −1 ) in coordinates with respect to the Lagrange basis on {0, 1}ℓ , collate the resultm0 −1
m0 −1
ing vector into an m0 × m1 matrix (ti )i=0
, and encode (ti )i=0
row-wise, so obtaining a further
m0 −1
m0 −1
m0 −1
matrix (ui )i=0 . Output a Merkle commitment c to (ui )i=0 and the opening hint u := (ui )i=0
.
• b ← Π.Open(params, c; t, u). On input the root c, opening t(X0 , . . . , Xℓ−1 ) ∈ K[X0 , . . . , Xℓ−1 ]⪯1 ,
and opening hint a set of distinct Merkle paths against c, missing the columns M ⊂ {0, . . . , n − 1},


?
m0 −1
m0 −1
m0 −1
and check ∆m0 (ui )i=0
, (Enc(ti ))i=0
∪ M < d2 .
say, write t into a matrix (ti )i=0
We define Π.Prove and Π.Verify by applying the Fiat–Shamir heuristic to the following interactive
m0 −1
protocol, where P has t(X0 , . . . , Xℓ−1 ) and (ui )i=0
, and P and V have c, s ∈ L, and (r0 , . . . , rℓ−1 ) ∈ Lℓ .
Nℓ−1
m0 −1
in the clear.
• P sends V the matrix–vector product t′ := i=ℓ1 (1 − ri , ri ) · (ti )i=0
• For each i ∈ {0, . . . , γ − 1}, V samples ji ← {0, . . . , n − 1}. V sends P the set J := {j0 , . . . , jγ−1 }.
o
n
m0 −1
• P sends V the columns (ui,j )i=0
, each featuring an accompanying Merkle path against c.
j∈J

d ′ ). For each j ∈ J, V verifies the Merkle path attesting to (ui,j )m0 −1 , and
• V computes u′ := Enc(t
i=0
Nℓ−1
Nℓ1 −1
?
m0 −1 ?
moreover checks i=ℓ1 (1 − ri , ri ) · (ui,j )i=0
= u′j . Finally, V requires s = t′ · i=0
(1 − ri , ri ).
d for the encoding function of the extension code C
b ⊂ Ln (see Subsection 3.1).
In the last step, we write Enc

14

Though Construction 3.7 is both binding and extractable, we refrain from proving as much; instead, we
defer our proofs of security to Subsection 3.4 below. The proof of security of Construction 3.7 above can be
obtained by specializing that subsection’s scheme’s proof to the case κ := 0.

3.4

Block-Level Encoding

In this subsection, we describe a variant of the polynomial commitment scheme of Subsection 3.3 above
suitable for polynomials over fields smaller than the alphabet of the linear block code selected for use. We
refer throughout to Guruswami [Gur06].
The simple scheme given in Construction 3.7 mandates the internal use of a code C ⊂ K n over the
same field K as that passed into Π.Setup(1λ , ℓ, K). In other words, it requires that Π.Setup return a code
C whose alphabet K is identical to the coefficient field K of the commitment scheme’s message space
K[X0 , . . . , Xℓ−1 ]⪯1 . This restriction presents no obstacle in theory, since constant-distance, constant-rate
families of codes exist even over arbitrarily small, fixed-size fields (this fact follows from the Gilbert–
Varshamov bound; see [Gur06, § 2.1]). Moreover, concretely good codes over small alphabets may be
obtained constructively using concatenated codes (see [Gur06, § 2.3]).
On the other hand, this restriction precludes the use of plain Reed–Solomon codes in Construction 3.7,
at least for certain combinations ℓ and K; indeed, a Reed–Solomon [n, k, d]-code over K can exist only when
|K| ≥ n. Reed–Solomon codes remain attractive, however, for various practical reasons. They attain the
Singleton bound, and so maximally favorably negotiate the tension between distance and rate. Separately,
they admit efficient encoding algorithms. Specifically, each code RSK,S [n, k]’s encoding function K k → K n
may be computed in Θ(n · log k) time, at least for certain alphabets K and evaluation sets S ⊂ K. Crucially,
we may number among these favorable alphabets the fields K of characteristic 2, due to relatively recent
work of Lin, Chung and Han [LCH14] (in that work, the evaluation sets S ⊂ K are certain F2 -affine linear
subspaces of K). We specialize from this point onwards to the binary tower setting (see Subsection 2.3).
Concatenated codes. In order to develop certain intuitions essential to our packing scheme, we first
examine the effect of instantiating Construction 3.7, as written, on a concatenated code. A concatenated
nout
, say, where κ ∈ N, and an
code C ⊂ Tιn is defined in terms of an outer [nout , kout , dout ]-code Cout ⊂ Tι+κ
κ
nin
inner [nin , kin , din ]-code Cin ⊂ Tι , where here we require kin = 2 . The resulting concatenated code is
an [n, k, d]-code over C ⊂ Tιn , where here we write n := nout · nin , k := kout · kin , and d := dout · din (we
refer to [Gur06, § 2.3] for further details). For example, upon concatenating the outer [215 , 214 , 214 + 1]-code
RST4 [215 , 214 ] over T4 with the inner [25 , 24 , 23 ]-code RMT0 [2, 5] over T0 , we would obtain a [220 , 218 , 217 +23 ]code over T0 (here, RMT0 [2, 5] denotes a certain Reed–Muller code).
The concatenated code construction requires that the inner code’s message space coincide with the outer
κ
code’s alphabet. Indeed, above, we leverage the natural identification Tι2 ∼
= Tι+κ of Tι -vector spaces (see
Subsection 2.3). In different words, we may interpret blocks of adjacent tower-field elements as elements of
a larger tower field. That is, given integers ι and κ in N, we may “pack” each block of 2κ Tι -elements into a
single Tι+κ -element.
We recall that the concatenated code C ⊂ Tιn ’s encoding procedure entails the following steps:
kout
• pack the initial message in Tιk into a vector in Tι+κ
,
nout
• encode the resulting vector using the outer code Cout ’s encoder, so obtaining a codeword in Tι+κ
,

• unpack each individual symbol of the resulting codeword into a message, in Tιkin , and finally
• encode each such message, using the inner code Cin , into a codeword in Tιnin , and concatenate them.
Construction 3.7, upon being instantiated with a concatenated code C ⊂ Tιn , and with the extension
field Tτ / Tι , say, would stipulate that the verifier perform the encoding operation attached to the extension
b ⊂ Tτn . This code is clearly well-defined (we recall Subsection 3.1); on the other hand, its encoding
code C
procedure is significantly more complicated than C’s is. We have already discussed above how one might
pack blocks of 2κ Tι -elements into Tι+κ -elements; in contrast, the corresponding packing operation on blocks
of 2κ Tτ -elements is more subtle.

15

The subtlety arises from the interplay of the three fields Tι , Tι+κ , and Tτ . In a sense, the packing
operation operates over a different dimension than does the field extension Tτ / Tι ; that is, it acts across
Tι -elements, instead of extending them. For the sake of intuition, we suggest imagining the parameterization
ι := 0, κ := 4, and τ := 7, as well as the concatenated code sketched above, throughout our treatment below.
Sketch of our approach. We explain the encoding procedure of a concatenated code’s extension code in
b ⊂ Tτn for its extension code. We
the following way. We again fix a concatenated code C ⊂ Tιn and write C
define a certain data structure which “packs” a number of Tι -elements into a rectangular array. This data
structure is depicted in Figure 1 below.
2κ

2τ −ι

⟨1⟩

⟨Y0 ⟩

⟨1⟩

Tι

Tι

⟨Xι ⟩

Tι


















⟨Xι · · · · · Xτ −1 ⟩

T... τ





















Tι

⟨Y0 · · · · · Yκ−1 ⟩

T ·ι+κ
··

Aι,κ,τ

···

Tι

..
.

Tι

Figure 1: A depiction of our “tower algebra” data structure.
Figure 1 depicts an array of 2τ −ι rows and 2κ columns (where, again, each cell is a Tι -element). The
b encoding procedure would pack each block of 2κ consecutive Tτ -elements of its message
extension code C’s
into exactly such an array, apply the outer code (whose alphabet is Tι+κ ) row-wise, and then finally apply
the inner code, again row-wise, to each component of the result.
In pursuit of an even simpler construction, we simply omit the inner code—that is, we use the identity
inner code—and use the Reed–Solomon outer code. Were we to instantiate Construction 3.7 naı̈vely on the
resulting concatenated code, we would encounter a relatively inefficient verifier; indeed, that concatenated
code features a relative distance kin -fold worse than the simple Reed–Solomon code’s. Instead, though
we do omit the inner code, we compensate by decreeing that the verifier test entire packed blocks of the
prover’s committed matrix, as opposed to testing individual columns. Crucially, we no longer view our code’s
encoding procedure as a Tι -linear one; rather, our code’s “symbols” are, now, packed chunks of Tι -elements.
To resuscitate our security analysis—which itself depends fundamentally on the proximity gap phenomenon
exhibited by error-correcting codes—we must investigate the sense in which the rows of our committed matrix
are, in fact, codewords of some different code. As it turns out, the array of Figure 1 can be endowed with a
certain algebraic structure—which we describe thoroughly throughout what follows—which, serving in the
capacity of the alphabet of a certain extension code, makes possible our adaptation of [DP24]’s security
analysis.
Interestingly, our block-level testing scheme achieves a proof size profile close to that which Construction
3.7 can attain even on a nontrivial concatenated code. (Comparing these approaches is of course difficult—
and in the limit, impossible—since the latter approach mandates the selection of an ad-hoc inner code for
each statement size. We opt simply to select the highest-distance known inner code for each statement size
we benchmark, and to avoid asymptotic comparisons.) At the same time, it’s significantly simpler, as well
as more efficient for the prover. These observations affirm our contention that, taken in full, this section’s
construction presents a compelling proposition. Indeed, we seek first of all to deliver a highly efficient prover;
on the other hand, our approach imposes only a mild cost on the verifier. We thoroughly benchmark these
schemes’ proof sizes in Table 1 below.
16

The tower algebra. We discuss, first informally and then precisely, two distinct multiplication operations,
defined on 2τ −ι × 2κ -sized arrays over Tι like that in Figure 1. To multiply the entire array by a Tι -element,
we may simply proceed cell-wise. We may moreover coherently define multiplication operations involving
elements of certain larger fields. For example, to multiply the entire array by a Tτ -element r ∈ Tτ , we may
interpret the array’s columns as Tτ -elements—respectively called ς0 , . . . , ς2κ −1 , say—and overwrite ςi ×= r
for each column index i ∈ {0, . . . , 2κ − 1}. On the other hand, we may moreover interpret each of the array’s
rows as a Tι+κ -element. We thus further define multiplication by Tι+κ -elements; that is, to multiply the entire
matrix by an element s ∈ Tι+κ , we interpret the array’s rows as Tι+κ -elements—called (ϑ0 , . . . , ϑ2τ −ι −1 ),
say—and overwrite ϑi ×= s for each i ∈ {0, . . . , 2τ −ι − 1}.
This “dual view” of the array—that is, either as an array of 2κ Tτ -elements, with a Tτ -vector space structure or as an array of 2τ −ι Tι+κ -elements, with a Tι+κ -vector space structure—will prove crucial throughout
our exposition of the packing scheme. Essentially, our packing scheme entails packing Tι -elements “horizontally”, into Tι+κ -elements, in order to encode them; in order to obtain cryptographic security, on the other
hand, we moreover extend them “vertically”, into Tτ -elements.
To make precise our packing scheme, we introduce a certain polynomial ring.
Definition 3.8. For parameters ι, κ, and τ in N, where τ ≥ ι, we define the tower algebra Aι,κ,τ as:

2
Aι,κ,τ := Tτ [Y0 , . . . , Yκ−1 ] / Y02 + Xι−1 · Y0 + 1, Y12 + Y0 · Y1 + 1, . . . , Yκ−1
+ Yκ−2 · Yκ−1 + 1 ,
where we understand Xι−1 as a Tτ -element (and slightly abuse notation by letting X−1 := 1 in case ι = 0).
We note that Aι,κ,τ admits a natural description as a 2κ -dimensional vector space over Tτ , via the
κ
basis 1, Y0 , Y1 , Y0 · Y1 , . . . , Y0 · · · · Yκ−1 . This basis yields an isomorphism aι,κ,τ : Tτ2 → Aι,κ,τ of Tτ -vector
spaces, which we call the natural embedding. The restriction of this embedding to its domain’s 0th factor
κ
Tτ ⊂ Tτ2 maps Tτ isomorphically to the subring Aι,0,τ ⊂ Aι,κ,τ consisting of the constant polynomials in
the indeterminates Y0 , . . . , Yκ−1 .
We understand the tower algebra in the following way. The formal variables Y0 , . . . , Yκ−1 define “synthetic analogues” of the variables Xι , . . . , Xι+κ−1 , which would—upon being adjoined to Tι —yield the field
extension Tι ⊂ Tι+κ ; moreover, these synthetic variables are designed to behave like their genuine analogues
(by means of the relations defining Aι,κ,τ ). In fact, this design gives rise to a certain key property of the
tower algebra, whereby the subring Aι,κ,ι ⊂ Aι,κ,τ consisting of those polynomials whose coefficients reside
exclusively in the subfield Tι ⊂ Tτ is precisely Tι+κ . We restate this essential property as follows:
κ

κ

κ

Theorem 3.9. The restriction aι,κ,τ |T 2κ : Tι2 → Aι,κ,τ of the natural embedding to the subset Tι2 ⊂ Tτ2
ι
is an injection of Tι -vector spaces, whose image, the subring Aι,κ,ι ⊂ Aι,κ,τ , is isomorphic as a ring to Tι+κ .
Proof. Indeed, the subring Aι,κ,ι ⊂ Aι,κ,τ is easily seen to be identical to Tι+κ , albeit with the variables
Xι , . . . , Xι+κ−1 respectively renamed to Y0 , . . . , Yκ−1 .
We implicitly, and unambiguously, understand Aι,κ,τ as a Tι -vector space in the first part of the statement
of Theorem 3.9; indeed, this action arises from the subring Tι ⊂ Aι,κ,τ consisting of those constant polynomials in the indeterminates Y0 , . . . , Yκ−1 whose constant—i.e., only—term resides in the subfield Tι ⊂ Tτ .
On the other hand, Theorem 3.9 shows that, over certain fields strictly larger than Tι , the ring Aι,κ,τ
admits multiple—and incompatible—vector space structures, a fact which we now take pains to explain
carefully. Of course, Aι,κ,τ has an obvious Tτ -action—already noted above—coming from the subring Tτ ∼
=
Aι,0,τ ⊂ Aι,κ,τ consisting of constant polynomials in the indeterminates Y0 , . . . , Yκ−1 . To distinguish this
subring from Theorem 3.9’s, we call it the constant subring throughout what follows. On the other hand,
Theorem 3.9 further realizes the field Tι+κ ∼
= Aι,κ,ι ⊂ Aι,κ,τ as the subring consisting of those arbitrary-degree
polynomials in the indeterminates Y0 , . . . , Yκ−1 whose coefficients, on the other hand, reside in Tι ⊂ Tτ . We
refer to Theorem 3.9’s subring, throughout what follows, as the synthetic subring. We take care below,
whenever we understand Aι,κ,τ as an algebra or as a vector space, to carefully specify the particular field,
and the particular vector space structure, that we intend. As a rule, whenever we speak of Aι,κ,τ as a
Tτ -algebra, we understand the constant subring; whenever we speak of it as a Tι+κ -algebra, we understand
the synthetic subring. (The constant and synthetic subrings appear in Figure 1 as the vertical and horizontal
shaded regions, respectively.)
17

We write (βu )u∈Bτ −ι for the multilinear Tι -basis of Tτ (i.e., for the basis 1, Xι , Xι+1 , Xι · Xι+1 , . . . , Xι ·
· · · · Xτ −1 ). We finally note that (βu )u∈Bτ −ι simultaneously yields a Tι+κ -basis of Aι,κ,τ —where we endow
the latter ring with the synthetic Tι+κ -vector space structure—provided that we identify each βu with the
constant polynomial βu in the indeterminates Y0 , . . . , Yκ−1 .
n
For each ι, κ, and τ in N, each tower algebra Aι,κ,τ , and each standard [n, k, d]-code C ⊂ Tι+κ
over
the alphabet Tι+κ , we recall the extension code construction of Definition 3.1. That is, in view of the
synthetic Tι+κ -vector space structure—i.e., that of Theorem 3.9—on Aι,κ,τ , C’s generator matrix induces a
n
n
d : Ak
b
map Enc
ι,κ,τ → Aι,κ,τ of Tι+κ -vector spaces; we write C ⊂ Aι,κ,τ for this map’s image. (Equivalently,
we may simply embed C’s generator matrix entry-wise along the subring Tι+κ ⊂ Aι,κ,τ of Theorem 3.9, and
b ⊂ An
view it as an Aι,κ,τ -matrix.) It is shown in Theorem 3.2 above that C
ι,κ,τ has distance d.
d
Importantly, we note that Enc is simultaneously Tτ -linear, where now we understand both Akι,κ,τ and
n
Aι,κ,τ as Tτ -vector spaces (via the constant embedding on each component). To show this, we observe first
d amounts to a matrix–vector product over the ring Aι,κ,τ (where we again synthetically embed
that Enc
Tι+κ ⊂ Aι,κ,τ ). On the other hand, any Tτ -linear combination of Akι,κ,τ -vectors can itself be expressed as
a scalar–vector combination over the ring Aι,κ,τ (where we now embed Tτ ⊂ Aι,κ,τ ). The Tτ -linearity of
d thus amounts to a distributive matrix identity over Aι,κ,τ ; on the other hand, matrix multiplication is
Enc
certainly distributive for arbitrary commutative rings.
We finally prepare the ground for our packing construction by recording a proximity gap result—that
is, an analogue of [DP24, Thm. 2]—for tower algebras. In the below theorem, we give meaning to the rowNℓ−1
m0 −1
combination i=ℓ1 (1 − ri , ri ) · (ui )i=0
by means of the constant Tτ -vector space structure on Aι,κ,τ . The
key difference between [DP24, Thm. 2] and Theorem 3.10 below, then, is that the code at hand has symbols
Nℓ−1
in the Tτ -vector space Aι,κ,τ , though the combination vector i=ℓ1 (1 − ri , ri ) nonetheless still has entries
in the ground field Tτ .
n
, with extension
Theorem 3.10 (Diamond–Posen [DP24, Thm. 2]). Fix an arbitrary [n, k, d]-code C ⊂ Tι+κ


d−1
n
b
code C ⊂ Aι,κ,τ , and a proximity parameter e ∈ {0, . . . , 3 }. If elements u0 , . . . , um0 −1 of Anι,κ,τ satisfy

Pr

 
h
 
d

ℓ

(rℓ1 ,...,rℓ−1 )∈Tτ


Nℓ−1

0

i=ℓ1 (1 − ri , ri )

i


·

u0
..
.
um0 −1







e+1
 b

,
, C  ≤ e > 2 · log m0 ·
|Tτ |



m0 −1 b m0
then dm0 (ui )i=0
,C
≤ e.
Proof. The proof goes through almost exactly as does that of [DP24, Thm. 2], with select modifications.
Indeed, we require only a substitute for the Schwartz–Zippel-based argument given in [DP24, Lem. 3]. In
our setting, each locus Rb,j ⊂ Tτℓ0 −1 is, now, the vanishing locus in Tτℓ0 −1 of a certain polynomial expression
in the variables (rℓ1 , . . . , rℓ−1 ), whose coefficients, on the other hand, reside in Aι,κ,τ (and moreover are
not all zero). Decomposing each such coefficient into a 2κ -tuple of Tτ -elements, using the natural Tτ -basis
1, Y0 , Y1 , . . . , Y0 · · · · Yκ−1 of Aι,κ,τ , we see that the vanishing locus Rb,j is the intersection in Tτℓ0 −1 of 2κ
vanishing loci, each itself the vanishing locus of a certain combination of the ℓ0 − 1-variate, multilinear
Lagrange basis polynomials in the standard polynomial ring Tτ [Rℓ1 , . . . , Rℓ−2 ]. Moreover, at least one
among these latter combinations features a nonzero combination vector. Applying Schwartz–Zippel to all 2κ
0 −1
loci, then, we see that at least one among these loci is bounded from above in mass by ℓ|T
, so that their
τ|
0 −1
intersection also is. This completes the argument that µ(Rb,j ) ≤ ℓ|T
. We note that an identical adaptation,
τ|
in the univariate setting, must also be made to the proof of [DP24, Thm. 1]. Up to these adjustments, the
proof of [DP24, Thm. 2] otherwise goes through in our setting without change.

Our construction. We now record our packing-based construction, which adapts and extends Construction 3.7 above. Slightly restricting that construction’s signature, we require that K take the form Tι , for
some ι (and that Π.Setup directly accept the parameter ι, instead of K).

18

CONSTRUCTION 3.11 (Block-level encoding-based polynomial commitment scheme).
We define Π = (Setup, Commit, Open, Prove, Verify) as follows.
• params ← Π.Setup(1λ , ℓ, ι). On input 1λ , ℓ, and ι, choose integers ℓ0 and ℓ1 for which ℓ0 + ℓ1 = ℓ,
ℓ0
and
m1 := 2ℓ1 . Return an integer κ ≥ 0, a tower height τ ≥ log(ω(log λ)), an
 mwrite
 m0 := 2 and
n
1
n, 2κ , d -code C ⊂ Tι+κ for which n = 2O(ℓ) and d = Ω(n), and a repetition parameter γ = Θ(λ).
• (c, u) ← Π.Commit(params, t). On input t(X0 , . . . , Xℓ−1 ) ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 , express t =
(t0 , . . . , t2ℓ −1 ) in coordinates with respect to the multilinear Lagrange basis and collate the result
m0 −1
row-wise into an m0 × m1 matrix (ti )i=0
. By grouping the column indices {0, . . . , m1 − 1} into
m0 −1
κ
2 -sized chunks and, for each row, applying the natural embedding chunk-wise, realize (ti )i=0
m1
as an m0 × 2κ matrix with entries in Tι+κ . Apply C’s encoding function row-wise to each of
m0 −1
m0 −1
(ti )i=0
’s rows; obtain in this way a further, m0 × n matrix (ui )i=0
, again with entries in Tι+κ .
m0 −1
m0 −1
.
Output a Merkle commitment c to (ui )i=0 and the opening hint u := (ui )i=0
• b ← Π.Open(params, c; t, u). On input the root c, opening t(X0 , . . . , Xℓ−1 ) ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 ,
and opening hint a set of distinct Merkle paths against c, missing the columns M ⊂ {0, . . . , n − 1},


?
m0 −1
m0 −1
m0 −1
say, write t into a matrix (ti )i=0
and check ∆m0 (ui )i=0
, (Enc(ti ))i=0
∪ M < d2 .
We define Π.Prove and Π.Verify by applying the Fiat–Shamir heuristic to the following interactive
m0 −1
protocol, where P has t(X0 , . . . , Xℓ−1 ) and (ui )i=0
, and P and V have c, s, and (r0 , . . . , rℓ−1 ) ∈ Tτℓ .
Nℓ−1
m0 −1
• P computes the matrix–vector product t′ :=
i=ℓ1 (1 − ri , ri ) · (ti )i=0 , here interpreting the
m0 −1
matrix (ti )i=0
as an unpacked, m0 × m1 matrix with entries in Tι . P sends V t′ in the clear.
• For each i ∈ {0, . . . , γ − 1}, V samples ji ← {0, . . . , n − 1}. V sends P the set J := {j0 , . . . , jγ−1 }.
m −1

0
• For each j ∈ J, P sends V the column (ui,j )i=0
, which it now interprets as a vector with entries
in the subring Aι,κ,ι ⊂ Aι,κ,τ , as well as an accompanying Merkle authentication path against c.

Nℓ1 −1
?
• V requires s = t′ · i=0
(1 − ri , ri ) (i.e., a simple dot-product over Tτ ). V then applies the natural
1
embedding to the Tτ -vector t′ , chunk-wise, so realizing it as a length- m
2κ vector with entries in
d ′ ), say. For each j ∈ J, V verifies
b writing u′ := Enc(t
Aι,κ,τ . V encodes this latter vector under C,
Nℓ−1
m0 −1
m0 −1 ?
the Merkle path attesting to (ui,j )i=0 , and moreover checks i=ℓ1 (1 − ri , ri ) · (ui,j )i=0
= u′j ,
where we use the constant Tτ -action on Aι,κ,τ on the left, and the equality is one of Aι,κ,τ -elements.
We again require that ι = O(log(λ)), lest the scheme fail to be efficiently computable; we moreover assume
that τ ≥ ι, so that the tower algebra Aι,κ,τ is well-defined. We note that the growth requirement τ ≥
log(ω(log λ)) captures precisely the condition whereby |T1τ | is negligible in λ. Indeed, while requiring τ ≥
Ω(log λ), say, would more-than-guarantee our scheme’s asymptotic security, the more delicate allowance
τ ≥ log(ω(log λ)) in fact suffices, and moreover figures centrally in our sharp asymptotic efficiency analysis
below (see Theorem 3.14).
We emphasize that Construction 3.11’s setup routine Π.Setup returns a code C over the alphabet Tι+κ ,
which—in general—is larger than the coefficient field Tι at hand. On the other hand, the efficiency of
Construction 3.11’s commitment phase is identical to that which Construction 3.7’s would achieve if that
1
construction were run on a Tι+κ -matrix of size m0 × m
2κ . In other words, Construction 3.11 makes possible the
κ
use of a code over an alphabet larger than Tι , by 2 -fold, say; it compensates for that expense by shrinking
the prover’s matrix 2κ -fold.
Construction 3.11’s completeness amounts to the “commutativity” of a certain sequence of actions on
m0 −1
m0 −1
the Tι -matrix (ti )i=0
; that is, (ti )i=0
either is combined, packed, and then encoded, or else is packed,
encoded, and then combined. Since the natural embedding is Tτ -linear, the first pathway’s combination and
packing operations can be interchanged. On the other hand, the interchangability of the combination and
d which we have already established.
encoding operations amounts exactly to the Tτ -linearity of Enc,

19

The proofs of the security results below draw heavily from [DP24, § 4].
Theorem 3.12. The scheme of Construction 3.11 is binding.
Proof. Deferred to Appendix A.
Theorem 3.13. If the query sampler Q is admissible, then the scheme of Construction 3.11 is extractable.
Proof. Deferred to Appendix A.

3.5

Efficiency

In this subsection, we discuss the concrete efficiency of Construction 3.11; to do this, we must also examine
its concrete soundness. A rudimentary treatment of this section’s material appears in [DP24, § 4.3].
Verifier cost. Departing slightly from standard efficiency analyses, we analyze both proof size and verifier
runtime under one banner; indeed, we view both metrics as disparate aspects of a unified verifier cost.
(This approach reflects the cost structure of Ethereum, say, in which each transaction’s calldata size and
verification complexity contribute jointly to its gas cost.) We define the relevant variables as follows:
• b: The cost, to the verifier, of each bit transmitted to it.
• Tι : The cost, to the verifier, of multiplying two Tι -elements.
• Tτ : The cost, to the verifier, of multiplying two Tτ -elements.
m1/2κ

• Enc: The cost, to the verifier, of encoding a message in Tι+κ

.

• Hash. The cost, to the verifier, of hashing a single Tι+κ -element.
We recall that a Tτ -element and a Tι -element can be multiplied together with cost 2τ −ι · Tι . Finally, we
ignore throughout the cost of addition (which amounts to bitwise XOR).
We reckon the verifier’s costs as follows. The prover must transmit to the verifier the message t′ , which
m0 −1
consists of m1 Tτ -elements, as well as the γ m0 -element columns (ui,j )i=0
, for j ∈ J, each valued in Tι+κ .
τ
ι+κ
The total proof size isN
thus 2 · m1 + 2
·N
m0 · γ bits. Computationally, the verifier must first compute
ℓ1 −1
ℓ−1
the tensor-expansions i=0
(1 − ri , ri ) and i=ℓ1 (1 − ri , ri ). Using the algorithm [Tha22, Lem. 3.8], the
verifier can compute these using m1 and m0 Tτ -multiplications, respectively. To encode the message t′ , the
n
’s encoding operation 2τ −ι times. In addition, the verifier must perform
verifier must perform C ⊂ Tι+κ
κ
γ · 2 Tτ -by-Tι dot products, each of length m0 . The total cost of these latter dot-products equals that of
m0 · γ · 2κ · 2τ −ι Tι -multiplications. Finally, the verifier must perform γ Merkle-path verifications. Each such
verification entails hashing a column of m0 Tι+κ -elements (as well as performing l1 further hash evaluations,
which we ignore).
Adding all of these components, we obtain the following total verifier costs:
• b: 2τ · m1 + 2ι+κ · m0 · γ.
• Tι : m0 · γ · 2τ −ι+κ .
• Tτ : m0 + m1 .
• Enc: 2τ −ι .
• Hash. γ · m0 .
We pause to record to the following fundamental asymptotic guarantee:
Theorem 3.14. For each fixed ι ∈ N,and arbitrary
ℓ and λ in N, Construction 3.11 can be instantiated in

√
ℓ
e
such a way as to impose verifier cost O λ · 2 , counting both bits transferred and bit-operations performed.
Proof. Deferred to Appendix A.
20

The analyses of Brakedown [Gol+23, Thm. 1] and Diamond and Posen [DP24, § 4.3] both measure just
field-elements transferred and field-operations. Theorem 3.14 performs a sharper asymptotic analysis; it
shows that—provided that it chooses τ sufficiently carefully—Construction 3.11 in fact attains square-root
verifier efficiency, in both in the security parameter and the polynomial’s size, even at the level of bits.
Concrete soundness. We identify and discuss, in concrete terms, the various sources of soundness error
which arise throughout Theorem 3.13. We refer throughout to the parameters d, n, γ, ι, κ, τ , m0 and m1 ,
recalling their roles in Π.Setup.
• Tensor batching error ΞB . This is the probability,
taken over the query sampler’s


 choice of
m0 −1 b m0
d
′ b
ℓ
m0
≥ 3 , we nonetheless have d u , C < d3 , where
(ui )i=0 , C
(r0 , . . . , rℓ−1 ) ← Tτ , that, though d
N
ℓ−1
m0 −1
we write u′ := i=ℓ1 (1 − ri , ri ) · (ui )i=0
. By Theorem 3.10 (see also Lemma A.1), ΞB ≤ 2 · ℓ0 · |Tdτ | .
• Non-proximal per-query error ΞN . This is the probability,
taken over the verifier’s choice of a

d
′ b
single index j ← {0, . . . , n − 1}, that, though d u , C ≥ 3 , nonetheless u′j = Enc(t′ )j holds. The
d
.
analysis of Lemma A.1 shows that ΞN ≤ 1 − 3·n

• Proximal per-query error ΞP . This is theprobability, taken over the verifier’s choice of a single
b < d but the message t′ ̸= Nℓ−1 (1 − ri , ri ) · (ti )m0 −1
index j ← {0, . . . , n − 1}, that, in case d u′ , C
i=ℓ1
i=0
3
2·d
.
is wrong, nonetheless u′j = Enc(t′ )j holds. The analysis of Lemma A.2 shows that ΞP ≤ 1 − 3·n

Putting these three sources of error together, and following the analyses of Lemmas A.1 and A.2, we
define the protocol’s total soundness error as follows:
Ξ := Ξ(d, n, γ, τ, ℓ0 , ℓ1 ) = max(ΞB + ΞγN , ΞγP ).

(1)

We justify this definition in the following way (in fact, this is a very rough summaryof the proof of Theorem
m −1 b m0
m −1
< d or
3.13). We note that either the prover’s committed matrix (ui ) 0
satisfies dm0 (ui ) 0 , C
i=0

i=0

3

it doesn’t. If it doesn’t, then the analysis of Lemma A.1 bounds the verifier’s acceptance probability from
m0 −1
above by ΞB + ΞγN . If it does, then the message list (ti )i=0
is well-defined, so that t′ is either correct or
it’s not; in that latter case, Lemma A.2 bounds the verifier’s probability of acceptance by ΞγP . Barring all of
these failure events, we indeed have that s = t(r0 , . . . , rℓ−1 ). We note that we slightly simplify our treatment
here by analyzing Construction 3.11 as an IOP, and ignoring the runtime of the emulator E, as well as the
m0 −1
probability that E aborts on a successful proof (say, because it fails to extract (ui )i=0
). This simplification,
in the setting of concrete analysis, is justified in Brakedown [Gol+23, p. 211], for example.
We define the bits of security obtained by Construction 3.11 as − log(Ξ).
Case studies. In order to concretely assess the performance characteristics of Construction 3.11, we study
various instantiations of that scheme. For comparison, we also explore various approaches based on the
use of concatenated codes in Construction 3.7. In each the following examples, we set ι := 0 (that is, we
commit to F2 -polynomials), as well as ℓ := 32, so that the total size of the polynomial at hand is 512 MiB.
Throughout each example, we attain 100 bits of security. To standardize the case studies’ respective prover
complexities, we consider only codes with the fixed rate ρ := 14 .
Example 3.15 (Reed–Solomon code with block-level testing). We begin with the efficiency of Construction
3.11. We first remark that the alphabet size parameter κ := 4 makes available only those width parameters
ℓ1
κ
ℓ1 at most 18; indeed, the Reed–Solomon requirement |K| ≥ n amounts to 22 = |Tκ | ≥ ρ1 · 22κ , or in
other words 2κ ≥ 2 + ℓ1 − κ. In fact, we set κ := 4, ℓ0 := 14 and ℓ1 := 18 (these choices yield the
smallest possible proofs). We thus have m1 = 218 , k = 214 , and n = 216 . Setting τ := 7—and using
d
d = n − k + 1 = 216 − 214 + 1 = 49,153—we compute ΞB ≤ 2 · 14 · 2128
≈ 2−107.608 . Moreover, we compute
d
2·d
the non-proximal per-query error ΞN ≤ 1 − 3·n
≈ 0.75 and the proximal per-query error ΞP ≤ 1 − 3·n
≈ 0.5.
Using a direct computation, we see that the total soundness error Ξ of equation (1) drops below 2−100 just
when the number of block-queries γ becomes 241 or greater. Using the expression for b given above, we
compute directly the proof size of 11.531 MiB, or about 226.527 bits.
21

Example 3.16 (Concatenated code with trivial inner code). For reference, we compare Example 3.15 to the
construction whereby a trivial concatenated code—i.e., with Reed–Solomon outer code and identity inner
code—is used in Construction 3.7 (i.e., without block-level testing). We again set κ := 4, ℓ0 := 14 and
ℓ1 := 18. In this setting, the resulting binary code has distance d = 49,153 identical to the code of the above
construction; on the other hand, its message length k = 218 and block length n = 220 are both 2κ -fold higher.
We thus obtain the identical batching error ΞB ≈ 2−107.608 ; our non-proximal and proximal per-query errors,
2·d
d
≈ 0.984 and ΞP = 1 − 3·n
≈ 0.969. Again calculating directly, we see
on the other hand, are ΞN = 1 − 3·n
that 4,402 single-column queries suffice to guarantee 100 bits of soundness. This scheme’s queries are each
16-fold cheaper than Example 3.15’s are; we obtain a total proof size of 12.598 MiB, or about 226.655 bits.
Example 3.17 (Nontrivial concatenated code). We finally examine the efficiency of Construction 3.7’s
instantiation on a nontrivial concatenated code (i.e., with nonidentity inner code). In order to run an
apples-to-apples comparison—i.e., between schemes whose prover costs are comparable—we set both our
inner and our outer codes’ rates to be 12 , so that our concatenated code has rate 41 . Specifically, we set
κ := 4, and set Cout ⊂ T4nout to be the Reed–Solomon code RST4 [215 , 214 ]; for Cin ⊂ T0kin , we use the
Reed–Muller [32, 16, 8]-code RMT0 [2, 5]. (We note that 8 is actually the best possible distance that a binary
[32, 16]-code can attain; we refer to the database of Grassl [Gra].) We see that our concatenated code
satisfies k = 218 and n = 220 , and has distance d = 8 · (214 + 1) = 131,080. We accordingly compute
d
2·d
d
≈ 2−106.193 , as well as ΞN = 1 − 3·n
≈ 0.958 and ΞP = 1 − 3·n
≈ 0.917. We calculate that
ΞB ≤ 2 · 14 · 2128
1,629 queries suffice to deliver 100 bits of soundness, and obtain a proof size of 7.182 MiB, or 225.844 bits.
Remark 3.18. We find it plausible that, in the setting of Example 3.15, the stronger proximity gap result of
Ben-Sasson, Carmon, Ishai, Kopparty, and Saraf [Ben+23, Thm.4.1] could be brought to bear. That result
} up to the unique decoding radius,
guarantees that, in the Reed–Solomon setting, for e ∈ {0, . . . , d−1
2
we obtain a proximity gap, albeit with the false witness probability |Tnτ | slightly worse than that of e+1
|Tτ |
guaranteed by [DP24, Thm. 1] (we refer to [DP24, § 2] for further comparison of these results). Of course, to
apply that result to Example 3.15, we would need an analogue of Theorem 3.10 above; that is, we would need
a result in the algebra setting which adapts [Ben+23, Thm. 4.1] precisely as Theorem 3.10 adapts [DP24,
Thm. 2]. While we feel confident that such an adaptation should be possible, we have not undertaken

it.
Alternatively, a strengthening of the general result [DP24, Thm. 2] to the larger range e ∈ {0, . . . , d−1
}
2
would have the same effect (we note the conjecture [DP24, Conj. 1]). If either of these expedients were
available, then, in Example 3.15, we would obtain the rather better proof size of 8.625 MiB, or 226.109 bits.
In Table 1, we record the benchmarks derived above, which pertain to the case ℓ = 32 (and thus 512 MiB
of total data), as well as benchmarks for the further case ℓ = 36 (corresponding to 8 GiB of total data).
Construction Used

Num. Variables ℓ

Parameters (ℓ0 , ℓ1 , κ)

Proof Size (MiB)

Reed–Solomon with block-level testing.

32

(14, 18, 4)

11.598

(See Example 3.15.)

36

(15, 21, 5)

62.206

32

(14, 18, 4)

8.669

(See Remark 3.18.)

36

(15, 21, 5)

50.553

Concatenated code w/ ad-hoc inner code.

32

(14, 18, 4)

7.278

(See Example 3.17.)

36

(16, 20, 5)

33.173

Reed–Solomon, assum. prox-gap

 d−1 
2

.

Table 1: Proof size benchmarks in the setting ρ = 41 .
In the final benchmark—that describing a concatenated code with κ := 5—we use the ad-hoc inner
[64, 32, 12]-code of Grassl [Gra] (this code is a subcode of an extended BCH code). As Grassl’s database
indicates, we are able neither to construct nor to rule out the existence of a binary [64, 32, 16]-code. The
existence of just such a code would further improve the benchmark given in the last row.
22

4

Polynomial IOPs for Binary Tower Fields

In this section, we review and develop several interactive protocols and polynomial IOPs, which we moreover
specialize to the setting of binary tower fields. We refer throughout to Chen, Bünz, Boneh and Zhang’s
HyperPlonk [CBBZ23, Def. 4.1], though we modify rather significantly that work’s formalisms.

4.1

Definitions and Notions

We fix throughout what follows a maximal tower height τ ∈ N; we understand τ := τ (λ) as depending on an
available security parameter.
Definition 4.1. A polynomial IOP Π = (I, P, V) is an interactive protocol in which the parties may freely
use a certain multilinear polynomial oracle, which operates as follows, on the security parameter λ ∈ N:
FUNCTIONALITY 4.2 (polynomial oracle).
A tower height τ := τ (λ) and a binary tower T0 ⊂ T1 ⊂ · · · ⊂ Tτ are fixed.
• On input (submit, ι, ℓ, t) from I or P, where ι ∈ {0, . . . , τ }, ℓ ∈ N, and t ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 ,
output (receipt, ι, ℓ, [t]) to I, P and V, where [t] is some unique handle onto the polynomial t.
• On input (query, [t], r) from V, where r ∈ Tτℓ , send V (evaluation, t(r0 , . . . , rℓ−1 )).
Definition 4.3. The polynomial IOP Π = (I, P, V) for the indexed relation R is secure if, for each PPT
adversary A, there exists an expected PPT emulator E and a negligible function negl, such that, for each
security parameter λ ∈ N and each pair (i, x), provided that the protocol is run on the security parameter
λ, writing vp := I(i) and w ← E A (i, x), we have |Pr[⟨A(i, x), V(vp, x)⟩ = 1] − Pr[R(i, x, w) = 1]| ≤ negl(λ).
We note that we grant E full internal access to A. In particular, E may intercept all outbound messages
sent by A, including those messages (submit, ι, ℓ, t) A sends directly to the polynomial oracle, as well as, of
course, those it sends to V. We note that, in practice, our emulator E will be straight-line (i.e., non-rewinding)
and strict polynomial-time, though these latter properties aren’t required by Definition 4.3.
It is shown by Bünz, Fisch and Szepieniec [BFS20, § E] that, by inlining an extractable polynomial
commitment scheme (in the sense of Definition 3.5) into a secure polynomial IOP (in the sense of Definition
4.3), one obtains a secure argument of knowledge for the relation R.
Definition 4.4. For parameters ι, ℓ, and µ in N, ℓ-variate, µ-ary polynomial predicate over Tι is a booleanvalued function Φι,ℓ : Tι [X0 , . . . , Xℓ−1 ]µ → {0, 1}.
Example 4.5. We record certain key polynomial predicates, roughly following HyperPlonk [CBBZ23].
1. Query. On parameters ι and ℓ in N, s ∈ Tτ , and r ∈ Tτℓ , sends Query(r, s)ι,ℓ : T 7→ T (r0 , . . . , rℓ−1 ) = s.
P
2. Sum. On parameters ι and ℓ in N and e ∈ Tι , sends Sum(e)ι,ℓ : T 7→ v∈Bℓ T (v) = e.
V
3. Zero. On parameters ι and ℓ in N, sends Zeroι,ℓ : T 7→ v∈Bℓ T (v) = 0.
4. Product.
OnQparameters ιVand ℓ in N, the binary product predicate sends Productι,ℓ : (T, U ) 7→
Q
T
(v)
= v∈Bℓ U (v) ∧ v∈Bℓ (T (v) = 0 ⇐⇒ U (v) = 0).
v∈Bℓ
5. Multiset. On parameters ι, ℓ, and µ in N, the 2 · µ-ary multiset predicate sends Multiset(µ)ι,ℓ :
(T0 , . . . , Tµ−1 , U0 , . . . , Uµ−1 ) 7→ {(T0 (v), . . . , Tµ−1 (v)) | v ∈ Bℓ } = {(U0 (v), . . . , Uµ−1 (v)) | v ∈ Bℓ },
where we understand both objects on the right-hand side as multisets (counted with multiplicity).
6. Permutation. On parameters ι, ℓ, and µ in N, and a bijection σ : {0, . . . , µ − 1} × Bℓ →
{0,
sends Permutation(σ)ι,ℓ : (T0 , . . . , Tµ−1 ) 7→
V . . . , µ − 1} × Bℓ , the′ µ-ary permutation predicate
′ ′ :=
′
T
(v
)
=
T
(v),
where
we
write
(i
,
v
)
σ(i, v) for each (i, v) ∈ {0, . . . , µ − 1} × Bℓ .
i
(i,v)∈{0,...,µ−1}×Bℓ i
V
7. Lookup. On parameters ι and ℓ in N, sends Lookupι,ℓ : (T, U ) 7→ v∈Bℓ ∃v ′ ∈ Bℓ : U (v) = T (v ′ ).
23

We note that each predicate Query(r, s)ι,ℓ can be evaluated directly by the verifier, on any handle [t], by
means of a single query to the polynomial oracle.
Our product predicate diverges from HyperPlonk’s [CBBZ23, § 3.3] in various respects. Their predicate
Q
T (v)
requires that the “denominator” U be everywhere-nonzero on the cube, as well as that the product v∈Bℓ U
(v)
equal a prescribed value. We simplify that predicate by specializing this prescribed value to 1; on the other
hand, we also more correctly handle the case of “division by zero” (their protocol actually fails to assert
that U is everywhere-nonvanishing on the cube). We discuss this matter further in Remark 4.15 below.
Finally, we present a permutation predicate slightly more sophisticated than HyperPlonk’s [CBBZ23, § 3.5];
specifically, ours supports permutations which act across multiple “columns”.
The following notational abstraction figures extensively in what follows.
Definition 4.6. An ℓ-variate virtual polynomial over Tι is a list [t0 ], . . . , [tµ−1 ] of handles, each representing
a polynomial defined over Tι , together with an arithmetic circuit, whose leaves are either indeterminates in
the list X0 , . . . Xℓ−1 or else constants in Tι , and in which we permit not just the binary gates + and ×, but
moreover, for each i ∈ {0, . . . , µ − 1}, the ℓi -ary gate ti (X0 , . . . , Xℓi −1 ) (assuming that ti is ℓi -variate). We
write T ∈ Tι [X0 , . . . , Xℓ−1 ] for the polynomial represented by the circuit, and [T ] for the virtual polynomial.
We note that each virtual polynomial [T ] may be evaluated at any input in Tιℓ —albeit in general, not
efficiently—by any machine that can query the handles [t0 ], . . . , [tµ−1 ]. We now treat efficient protocols for
virtual polynomials.
Definition 4.7. A virtual polynomial protocol for the µ-ary polynomial predicate Φι,ℓ is an interactive
protocol Σ = (P, V) which takes as common input a list ([T0 ], . . . , [Tµ−1 ]) of ℓ-variate virtual polynomials.
The protocol Σ is secure with respect to Φι,ℓ if, for each PPT adversary A, there is a negligible function
negl for which, for each λ ∈ N and each input list ([T0 ], . . . , [Tµ−1 ]), if the protocol is run on the security
parameter λ, then we have Pr[⟨A(T0 , . . . , Tµ−1 ), V([T0 ], . . . , [Tµ−1 ])⟩ = 1 ∧ Φι,ℓ (T0 , . . . , Tµ−1 ) = 0] ≤ negl(λ).
We highlight, in particular, the special case of Definition 4.7 in which Φι,ℓ takes the form Query(r, s)ι,ℓ .
Definition 4.8. An evaluation protocol for the ℓ-variate virtual polynomial [T ] over Tι is a family of virtual
polynomial protocols, parameterized by r ∈ Tτℓ and s ∈ Tτ , for the predicates Query(r, s)ι,ℓ on the input [T ].
In practice, we often attach to each virtual polynomial T an appropriate evaluation protocol, and refer
to the resulting bundle as an evaluable virtual polynomial.
Example 4.9 (Compositions). A certain simple sort of virtual polynomial arises from a list of ℓ-variate
handles [t0 ], . . . , [tµ−1 ] and a µ-variate composition polynomial g ∈ Tι [X0 , . . . , Xµ−1 ]. From these, we obtain
the composition virtual polynomial T := g(t0 (X0 , . . . , Xℓ−1 ), . . . , tµ−1 (X0 , . . . , Xℓ−1 )). We note that [T ]
admits an efficient evaluation protocol, at least if g is succinct; indeed, to decide the predicate Query(r, s)ι,ℓ ,
V may query each of the handles at r, evaluate g itself on the results, and finally compare the result to s.
Example 4.10 (Piecewise multilinears). A further sort of virtual polynomial arises in the following way.
For integers ι, ℓ, and µ in N, where µ = 2α is a power of 2, say, and ℓ-variate handles [t0 ], . . . , [tµ−1 ] over Tι ,
B
we introduce a piecewise function T ∈ Tι ℓ+α , defined so that, for each v ∈ Bℓ and u ∈ Bα , T (u ∥ v) = t{u} (v)
Pα−1
holds (we recall the identification {u} := i=0 2i · ui ). We finally identify T with its multilinear extension
T (X0 , . . . , Xℓ+α−1 ) ∈ Tι [X0 , . . . , Xℓ+α−1 ]⪯1 . We note that T defines a valid virtual polynomial in the handles
[t0 ], . . . , [tµ−1 ]; moreover, T is evaluable, provided µ is small. Indeed, to decide Query(r, s)ι,ℓ+α , say, V may
destructure (r0 , . . . , rℓ+α−1 ) := r, query the polynomials [t0 ], . . . , [tµ−1 ] at (rα , . . . , rℓ+α−1 ), obtaining the
Nα−1
? Nα−1
µ−1
results s0 , . . . , sµ−1 , say, and finally output s = i=0 (1 − ri , ri ) · (si )i=0 (here, i=0 (1 − ri , ri ) is a tensor
product expansion in the sense of Subsection 2.2, and can be computed in Θ(µ) time). The correctness of
this procedure is essentially [Tha22, Lem. 3.6]. We write [T ] := merge([t0 ], . . . , [tµ−1 ]) for this construction.
We finally note that virtual polynomials can be composed. Indeed, upon replacing some among the
handles [t0 ], . . . , [tµ−1 ] of some virtual polynomial [T ] with further virtual polynomials, we may nonetheless
“unroll” the resulting object into a proper virtual polynomial [T ′ ] in its own right. Finally, if [T ] and all of
the sub-virtual polynomials are efficiently evaluable, then the composed virtual polynomial [T ′ ] also is.

24

4.2

Prior Virtual Polynomial Protocols

We develop various virtual protocols, following Thaler [Tha22] and HyperPlonk [CBBZ23, § 3]. We adapt
generally without great change that latter work’s techniques, though we variously clarify and refine them.
Sumcheck.
The sumcheck protocol is a virtual polynomial protocol for the predicate Sum(e)ι,ℓ : T 7→
P
T
(v)
=
e. Internally, on input an evaluable, ℓ-variate virtual polynomial [T ], sumcheck invokes [T ]’s
v∈Bℓ
implicit Query(r, s)ι,ℓ protocol, on parameters r ∈ Tτℓ and s ∈ Tτ derived during the course of the sumcheck.
The definition of the sumcheck protocol, as well as a proof that it securely evaluates Sum(e)ι,ℓ in the sense
of Definition 4.7, appear in Thaler [Tha22, § 4.1]. The protocol’s soundness error is at most |Tℓ·dτ | , where
d is the maximum individual degree exhibited by any of T ’s variables (plus the error inherent to [T ]’s
evaluation protocol). We emphasize that the known, highly-efficient algorithms for the sumcheck protocol’s
prover require that [T ] take the particular form given in Example 4.9 (i.e., that [T ] be a composition of
multilinears); we refer to [Tha22, Lem. 4.5] for a discussion of these algorithms.
V
Zerocheck. We recall the predicate Zeroι,ℓ : T 7→ v∈Bℓ T (v) = 0, as well as the zerocheck protocol of
HyperPlonk [CBBZ23, § 3.2] (see also Spartan [Set20]).
PROTOCOL 4.11 (Zerocheck).
Parameters ι, ℓ, and τ in N and an ℓ-variate virtual polynomial [T ] over Tι is fixed.
• V samples r ← Tℓτ , and sends r to P.
• P and V run the sumcheck protocol, with statement 0, on the virtual polynomial [T ′ ] :=
T (X0 , . . . , Xℓ−1 ) · e
fq(r0 , . . . , rℓ−1 , X0 , . . . , Xℓ−1 ).
We note first of all that [T ′ ] is a valid virtual polynomial, which moreover admits its own evaluation protocol.
Indeed, to decide Query(r′ , s′ )τ,ℓ (T ′ ), say, V may, after first locally evaluating a := e
fq(r, r′ )—which takes
?

O(ℓ) work—immediately return s′ = 0 in case a= 0, and otherwise proceed with the appropriate protocol
′

(i.e., that attached to [T ]) deciding Query r′ , sa

(T ).

ι,ℓ

Theorem 4.12. Protocol 4.11 securely decides the predicate Zeroι,ℓ on T .
Proof. Assuming that Zeroι,ℓ (T ) = 0, we show that Sum(0)τ,ℓ (T ′ ) = 1 holds with negligible probability
e
over
P V’s random coins. Our hypothesis implies precisely that T ’s multilinear extension T (X0 , . . . , Xℓ−1 ) =
fq(X0 , . . . , Xℓ−1 , v0 , . . . , vℓ−1 ) is not identically zero. By the Schwartz–Zippel lemma, the
v∈Bℓ T (v) · e
probability, over V’s choice of r ← Tτℓ , that Te(r) = 0 is thus at most |Tℓτ | . On the other hand, if Te(r) ̸= 0,
P
then v∈Bℓ T (v) · e
fq(r0 , . . . , rℓ−1 , v0 , . . . , vℓ−1 ) ̸= 0 holds, so that Sum(0)τ,ℓ (T ′ ) is false, as required.
The soundness error of the zerocheck protocol thus |Tℓτ | + (d+1)·ℓ
|Tτ | , where d, again, is the maximum
individual degree exhibited by any of T ’s variables (plus, again, the error inherent to [T ]’s implicit evaluation
protocol). The first of these two terms is a zerocheck-specific soundness error; the term (d+1)·ℓ
arises from
|Tτ |
′
zerocheck’s internal use of the sumcheck on [T ].
Q
Product
check.
We now record a protocol for the product predicate Productι,ℓ : (T, U ) 7→ v∈Bℓ T (v) =
Q
V
v∈Bℓ U (v) ∧
v∈Bℓ (T (v) = 0 ⇐⇒ U (v) = 0) above, roughly following Setty and Lee’s Quarks [SL20, § 5]
and HyperPlonk [CBBZ23, § 3.3].
PROTOCOL 4.13 (Product check).
Parameters ι and ℓ in N, and ℓ-variate virtual polynomials [T ] and [U ] over Tι , are fixed.
T (v)
• P defines the function f ∈ TιBℓ as follows. For each v ∈ Bℓ , P sets f (v) := U
(v) if U (v) ̸= 0 and

25

f (v) := 1 otherwise. P submits (submit, ι, ℓ + 1, f ′ ) to the oracle, where f ′ ∈ Tι [X0 , . . . , Xℓ ]⪯1 is
such that, for each v ∈ Bℓ , both f ′ (v ∥ 0) = f (v) and f ′ (v ∥ 1) = f ′ (0 ∥ v) · f ′ (1 ∥ v) hold.
• Upon receiving (receipt, ι, ℓ + 1, [f ′ ]) from the oracle, V submits (query, [f ′ ], (0, 1, . . . , 1)) to the
?

oracle; V requires that the response (evaluation, f ′ (0, 1, . . . , 1)) satisfy f ′ (0, 1, . . . , 1) = 1.
• P and V define an ℓ + 1-variate virtual polynomial [T ′ ] as follows:
[T ′ ] := merge([T ], [f ′ ](· ∥ 1)) − merge([U ], [f ′ ](0 ∥ ·)) · merge([f ′ ](· ∥ 0), [f ′ ](1 ∥ ·)).
P and V run a zerocheck on the virtual polynomial [T ′ ].
Above, the virtual polynomial expression [f ′ ](· ∥ 0) denotes the ℓ-variate partial evaluation of [f ′ ] which
specializes that polynomial’s last variable to 0; its variants are analogous.
We modify the protocol given in [CBBZ23, § 3.3] in two distinct ways. On the one hand, our prover
constructs the auxiliary function f in such a way as to appropriately handle the vanishing of the “denominator” U within the cube; we discuss this issue further in Remark 4.15. Separately, we define
the virtual polynomial [T ′ ] above—that is, the target of the zerocheck reduction—differently than does
[CBBZ23, § 3.3], as we presently explain. The work [CBBZ23, § 3.3] sets (adapting their notation to ours)
[T ′ ] := merge([T ] − [U ] · [f ′ ](· ∥ 0), [f ′ ](· ∥ 1) − [f ′ ](0 ∥ ·) · [f ′ ](1 ∥ ·)). While this construction is correct—
and in fact agrees with our [T ′ ] identically on Bℓ+1 —it suffers from the defect whereby [T ′ ] is not a composition of multilinears in the sense of Example 4.9 (even if T and U are themselves multilinear), and so fails to
admit an obvious efficient sumcheck. Our construction remedies this issue, in that our [T ′ ] is a composition
of multilinears, at least if T and U are themselves multilinear. We emphasize that our protocol is correct
and secure regardless of T and U ; on the other hand, the efficiency of its implementation may require that
T and U be multilinear (as they will be in our applications below).
Theorem 4.14. Protocol 4.13 securely decides the predicate Productι,ℓ on [T ] and [U ].
Proof. Assuming that V accepts and that Zeroι,ℓ+1 (T ′ ) = 1, where T ′ is the virtual polynomial constructed
during Protocol 4.13, we show that Productι,ℓ (T, U ) = 1 holds with probability 1. It follows directly from the
definition of merge that, under our hypothesis Zeroι,ℓ+1 (T ′ ) = 1 we have, for each v ∈ Bℓ , that both T (v) =
U (v) · f ′ (v ∥Q
0) and f ′ (v ∥ 1) = f ′ (0 ∥ v) · f ′ (1 ∥ v) hold. This latter equality, in light of [SL20, Lem 5.1],
implies that v∈Bℓ f ′ (v ∥ 0) = f ′ (0, 1, . . . , 1), which in turn equals 1 whenever V Q
accepts. TakingQ
the product
of the former equality over Q
all v ∈ Bℓ , we thus conclude immediately that v∈Bℓ T (v) = v∈Bℓ U (v).
Separately, from the relation v∈Bℓ f ′ (v ∥ 0) = 1, we conclude that, for each v ∈ Bℓ , f ′ (v ∥ 0) is individually
nonzero, so that the guarantee T (v) = U (v) · f ′ (v ∥ 0) in particular implies T (v) = 0 ⇐⇒ U (v) = 0.
The product check protocol—once fully unrolled—makes just one query each to [T ] and [U ]. Its soundness
error is thus that of the zerocheck protocol (when run on [T ′ ]), together with whatever error arises from [T ]
[U ]’s respective implicit query protocols.
Remark 4.15. We compare our treatment of the product and multiset predicates to HyperPlonk’s [CBBZ23,
§§ 3.3–3.4]. HyperPlonk’s product protocol [CBBZ23, § 3.3] purports to securely decide the predicate
V
Q
T (v)
(T, U ) 7→ v∈Bℓ U (v) ̸= 0 ∧ v∈Bℓ U
(v) = e, where e ∈ Tι is a statement. In words, HyperPlonk’s stated
predicate requires that the denominator U be nowhere-vanishing on the cube, as well as that the product,
over the cube, of the pointwise quotient between T and U equal e. In actuality, that protocol decides a
more-complicated predicate, as we now explain. The predicate actually decided by that protocol allows U
to vanish on the cube, albeit with caveats. Indeed, it requires in that case merely that the numerator T also
vanish wherever U does, as well as that, if U happens to vanish anywhere, then T and U fulfill a weaker
variant of the product relationship whereby, if e ̸= 0, then T is nonzero wherever U is. In simple terms, by
setting T and U both equal to 0 at v ∗ ∈ Bℓ , say, the prover may cause the verifier to accept for arbitrary
e (provided, again, that T is nonzero wherever U is, a circumstance which the prover can easily arrange).
This
Q attack breaks
Q the security
V of [CBBZ23, § 3.3] as stated. We note that, in this situation, our relation
v∈Bℓ T (v) =
v∈Bℓ U (v) ∧
v∈Bℓ (T (v) = 0 ⇐⇒ U (v) = 0) does hold, while HyperPlonk’s does not; the
issue is an illegal “division by 0”. In fact, our relation Productι,ℓ above is precisely the specialization of the
“complicated” relation just described to the case e := 1 (where significant simplifications emerge).
26

V
Remark 4.16. Were we to remove the conjunct v∈Bℓ (T (v) = 0 ⇐⇒ U (v) = 0) from the predicate
Productι,ℓ above, Protocol 4.13 would cease to be complete. Indeed, upon initiating Protocol 4.13 on polynomialsQT and U for Q
which, at the point v ∗ ∈ Bℓ let’s say, U (v ∗ ) ̸= 0 and T (v ∗ ) = 0 both held—and for
which v∈Bℓ T (v) = v∈Bℓ U (v) moreover held, let’s say (so that U (v) = 0 for some v ∈ Bℓ \ {v ∗ })—P
would find itself unable to generate aQpassing proof. Indeed, to pass, P would have to set f ′ (v ∗ ∥ 0) = 0;
this would necessitate, in turn, that v∈Bℓ f ′ (v ∥ 0) = f ′ (0, 1, . . . , 1) = 0. Separately, assuming U (v ∗ ) = 0
and T (v ∗ ) ̸= 0, P would become unable to select f ′ (v ∗ ∥ 0) so as to cause T (v ∗ ) = U (v ∗ ) · f ′ (v ∗ ∥ 0) to hold.
Multiset check. We recall the 2 · µ-ary multiset predicate Multiset(µ)ι,ℓ : (T0 , . . . , Tµ−1 , U0 , . . . , Uµ−1 ) 7→
{(T0 (v), . . . , Tµ−1 (v)) | v ∈ Bℓ } = {(U0 (v), . . . , Uµ−1 (v)) | v ∈ Bℓ }, where the equality is of multisets. HyperPlonk [CBBZ23, § 3.4] defines a protocol for Multiset(µ)ι,ℓ in two steps, first by reducing Multiset(1)ι,ℓ to
Productι,ℓ , and then by reducing Multiset(µ)ι,ℓ , for k > 1, to Multiset(1)ι,ℓ . Though our treatment is similar
to HyperPlonk’s, we reproduce the details for self-containedness.
PROTOCOL 4.17 (1-dimensional multiset check [CBBZ23, § 3.4]).
Parameters ι, ℓ and τ in N, and ℓ-variate virtual polynomials [T0 ] and [U0 ] over Tι , are fixed.
• V samples r ← Tτ , and sends r to P.
• P and V run a product check on the virtual polynomials [T ′ ] := r − [T0 ] and [U ′ ] := r − [U0 ].
Theorem 4.18. Protocol 4.17 securely decides the predicate Multiset(1)ι,ℓ on [T0 ] and [U0 ].
Proof. We follow [CBBZ23, Thm. 3.4], with appropriate adaptations. Assuming Multiset(1)ι,ℓ (T0 , U0 ) = 0,
we argue that Productτ,ℓ (T ′ , U ′ ) = 1 holds with negligible probability over the verifier’s random coins.
Q
Our hypothesis entails directly that the degree-2ℓ , univariate polynomials Tb(Y ) := v∈Bℓ (Y − T0 (v)) and
b (Y ) := Q
U
v∈Bℓ (Y − U0 (v)), which we now view as elements of Tτ [Y ], are unequal. We see that the difference
b (Y ) is not identically zero, and moreover of degree at most 2ℓ ; we write R ⊂ Tτ for its roots. If
Tb(Y ) − U
Q
Q
r ̸∈ R, then v∈Bℓ (r − T0 (v)) ̸= v∈Bℓ (r − U0 (v)), so that Productτ,ℓ (T ′ , U ′ ) = 0 necessarily holds.
V
Remark 4.19. The conjunct v∈Bℓ (T (v) = 0 ⇐⇒ U (v) = 0) in our product predicate—which serves
to make our product check Protocol 4.13 complete (see Remark 4.16)—unfortunately makes Protocol
4.17 incomplete, albeit with negligible probability. Indeed, assuming that T0 and U0 are such that
Multisetι,ℓ (T0 , U0 ) = 1, the polynomials T ′ and U ′ produced during Protocol 4.17 fail to satisfy Productι,ℓ if
and only if, for some v ∗ ∈ Bℓ for which T0 (v) ̸= U0 (v), the verifier’s random scalar r satisfies r = T0 (v) or
ℓ
r = U0 (v). This event in turn can happen with probability at most |T2τ | , which is negligible. An identical
issue affects HyperPlonk’s one-dimensional multiset check [CBBZ23, § 3.4] (and, in fact, does so regardless
of whether that protocol’s product predicate is amended along the lines suggested by Remark 4.15).
We now present the protocol for 2 · µ-ary multiset check, exactly following [CBBZ23, § 3.4].
PROTOCOL 4.20 (µ-dimensional multiset check [CBBZ23, § 3.4]).
Parameters ι, ℓ, and τ in N, as well as ℓ-variate virtual polynomials [T0 ], . . . , [Tµ−1 ] and [U0 ], . . . , [Uµ−1 ]
over Tι , where µ > 1, are fixed.
• V samples random scalars r1 , . . . , rµ−1 from Tτ , and sends them to P.
• P and V run a 1-dimensional multiset check on the virtual polynomials [T ′ ] := [T0 ] + r1 · [T1 ] +
· · · + rµ−1 · [Tµ−1 ] and [U ′ ] := [U0 ] + r1 · [U1 ] + · · · + rµ−1 · [Uµ−1 ].
µ−1

µ−1

Theorem 4.21. Protocol 4.20 securely decides the predicate Multiset(µ)ι,ℓ on ([Ti ])i=0 and ([Ui ])i=0 .
Proof. Assuming that Multiset(µ)ι,ℓ (T0 , . . . , Tµ−1 , U0 , . . . , Uµ−1 ) = 0, we show that Multiset(1)ι,ℓ (T ′ , U ′ ) = 1
holds with negligible probability over V’s random coins. We follow the proof strategy of [CBBZ23, Thm. 3.5].
We write T := {(T0 (v), . . . , Tµ−1 (v)) | v ∈ Bℓ } and U := {(U0 (v), . . . , Uµ−1 (v)) | v ∈ Bℓ } for the multisets at
27

b := U \ T , which we understand as multiset differences. Since T and U are
hand, as well as Tb := T \ U and U
b necessarily also are; moreover, our hypothesis entails precisely that Tb
equally sized as multisets, Tb and U

b are nonempty. We fix an element t∗ ∈ Tb. We write R := (1, r1 , . . . , rµ−1 ) (r1 , . . . , rµ−1 ) ∈ Tτµ−1 ;
and U
µ
moreover, for each r ∈ R, we write φr : Tτn
→ Tτ for the map φr : o(a0 , . . . , aµ−1 ) 7→ a0 +r1 ·a1 +· · ·+rµ−1 ·aµ−1 .
S
?
b
Finally, for each u ∈ U , we set Ru := r ∈ R φr (t∗ ) = φr (u) . If the verifier’s challenge r ̸∈
b Ru ,
u∈U

then Multiset(1)ι,ℓ (T ′ , U ′ ) = 0 certainly holds; indeed, in this case, the count of the element φr (t∗ ) in the
multiset {φr (t) | t ∈ T } necessarily exceeds by at least 1 the count of this element in {φr (u) | u ∈ U }, so
that {φr (t) | t ∈ T } =
̸ {φr (u) | u ∈ U }. On the other hand, each Ru is precisely the intersection in Tτµ
between the affine hyperplane R and the normal hyperplane {r ∈ Tτµ | r · (t∗ − u) = 0} (which is necessarily
nondegenerate, by our choice of t∗ ). Each Ru is thus a proper affine subspace of R, and so covers a proportion
S
b | · 1 ≤ 2ℓ among R’s
consisting of at most |T1τ | of R’s points. The union u∈Ub Ru thus covers at most |U
|Tτ |
|Tτ |
b | here is a multiset cardinality). This completes the proof.
points (where |U
Permutation
check. We finally describe a protocol for the predicate Permutation(σ)ι,ℓ : (T0 , . . . , Tµ−1 ) 7→
V
′
′
(i,v)∈{0,...,µ−1}×Bℓ Ti (v ) = Ti (v) above; here, as before, we fix a bijection σ : {0, . . . , µ − 1} × Bℓ →
{0, . . . , µ − 1} × Bℓ . Though we follow HyperPlonk [CBBZ23, § 3.5], our protocol decides an extension of
that work’s predicate, which allows multiple inputs, as well as permutations that act across these inputs.
Our protocol takes as common input a list [T0 ], . . . , [Tµ−1 ] of virtual polynomials. It also—unlike the
protocols already given above—makes use of the indexer; specifically, the protocol takes as further common
input handles [sid ] and [sσ ], which jointly capture the permutation σ : {0, . . . , µ−1}×Bℓ → {0, . . . , µ−1}×Bℓ .
We argue first that we may freely assume that µ = 2α is a power of 2; indeed, we may always extend σ by the
identity map, as well as pad the list [T0 ], . . . , [Tµ−1 ] with further virtual polynomials (set to be identically
zero, say). Clearly, the padded predicate holds if and only if the unpadded one does.
We fix an arbitrary injection s : {0, . . . , µ − 1} × Bℓ ,→ Tτ (we assume without further comment that
τ is sufficiently large). For each i ∈ {0, . . . , µ − 1}, we define mappings idi : Bℓ → Tτ and σi : Bℓ → Tτ
by setting idi : v 7→ s(i, v) and σi : v 7→ s(σ(i, v)). We finally write sid := merge(id0 , . . . , idµ−1 ) and
sσ := merge(σ0 , . . . , σµ−1 ), following Example 4.10. We stipulate that the indexer output [sid ] and [sσ ]
directly as ℓ + α-variate handles (though this latter measure is not necessary, it improves efficiency).
PROTOCOL 4.22 (Permutation check [CBBZ23, § 3.4]).
Parameters ι, ℓ, and τ in N, the handles [sid ] and [sσ ] constructed above, a bijection σ : {0, . . . , µ − 1} ×
Bℓ → {0, . . . , µ − 1} × Bℓ , and ℓ-variate polynomials [T0 ], . . . , [Tµ−1 ] are fixed.
• P and V construct the virtual polynomial [T ] := merge(T0 , . . . , Tµ−1 ).
• P and V run a 4-ary multiset check on the ℓ + α-variate pairs ([sid ], [T ]) and ([sσ ], [T ]).
Theorem 4.23. Protocol 4.22 securely decides the predicate Permutation(σ)ι,ℓ on [T0 ], . . . , [Tµ−1 ].
Proof. Assuming that Multiset(2)ι,ℓ (sid , T, sσ , T ) = 1, we show that Permutation(σ)ι,ℓ (T0 , . . . , Tµ−1 ) = 1
holds with probability 1. We write Tbid := {(sid (u), T (u)) | u ∈ Bℓ+α } and Tbσ := {(sσ (u), T (u)) | u ∈ Bℓ+α }
(both viewed as multisubsets of Tτ2 ). We let (i, v) ∈ {0, . . . , µ−1}×Bℓ be arbitrary, and write (i′ , v ′ ) := σ(i, v).
We note that the multisets Tbid and Tbσ each admit precisely one element whose 0th component equals s(i′ , v ′ );
indeed, these elements are exactly (s(i′ , v ′ ), Ti′ (v ′ )) and (s(i′ , v ′ ), Ti (v)), respectively, by construction of sid ,
sσ , and T . By the assumed equality of Tbid and Tbσ of multisets, we conclude that Ti′ (v ′ ) = Ti (v).

4.3

New Virtual Polynomials

We now introduce a handful of new virtual polynomial constructions. Each of these constructions, on input
a handle (or a virtual polynomial), materializes a further virtual polynomial, whose relationship to its input
is prescribed.

28

The packing construction. We fix integers ι, κ, τ , and ℓ in N. We recall from Subsection 2.3 the
multilinear Tι -basis (βu )u∈Bκ of Tι+κ . We finally fix a vector t ∈ TιBℓ .
B

ℓ−κ
We define the packing operator packκ : TιBℓ → Tι+κ
by setting:

packκ (t)(v) :=

X

t(u ∥ v) · βu

u∈Bκ

for each v ∈ Bℓ−κ .
Intuitively, packκ iteratively processes chunks consisting of 2κ lexicographically adjacent Tι -elements; it
assembles the constituents of each such chunk into a single Tι+κ -element.
We now record a virtual polynomial materialization of packκ (t). For t ∈ TιBℓ again as above, we write
e
] κ (t) ∈ Tι+κ [X0 , . . . , Xℓ−κ−1 ]⪯1 for the MLE
t ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 for the MLE of t; we moreover write pack
] κ (t):
of packκ (t). We have the following explicit expression for pack
X
e
] κ (t)(X0 , . . . , Xℓ−κ−1 ) =
pack
t(u0 , . . . , uκ−1 , X0 , . . . , Xℓ−κ−1 ) · βu ,
u∈Bκ

where we destructure (u0 , . . . , uκ−1 ) = u for each u ∈ Bκ . Indeed, for each (v0 , . . . , vℓ−κ−1 ) = v ∈ Bℓ−κ ,
] κ (t)(v0 , . . . , vℓ−κ−1 ) = packκ (t)(v); moreover, the polynomial above is multilinear.
pack
] κ (t)(X0 , . . . , Xℓ−κ−1 ) defines an ℓ − κ-variate virtual
When e
t is given as a handle [t], the expression pack
polynomial, in the sense of Definition 4.6. In fact, this virtual polynomial admits an efficient evaluation
] κ (t)(r′ ) =
protocol,
as we now argue. We fix a query Query(r′ , s′ )ι+κ,ℓ−κ . We note that the evaluation pack
P
′
′
e
u∈Bκ t(u0 , . . . , uκ−1 , r0 , . . . , rℓ−κ−1 ) · βu is itself the sum, over Bκ , of the κ-variate polynomial:
′
e 0 , . . . , Yκ−1 );
] κ (t, r′ )(Y0 , . . . , Yκ−1 ) := e
pack
t(Y0 , . . . , Yκ−1 , r0′ , . . . , rℓ−κ−1
) · β(Y

here, we write βe ∈ Tι+κ [Y0 , . . . , Yκ−1 ]⪯1 for the MLE of (βu )u∈Bκ . It thus suffices for the verifier to decide
] κ (t, r′ ). Using the sumcheck protocol, the verifier may in turn reduce that predicate to
Sum(s′ )τ,κ on pack
?
e
] κ (t, r′ ). To decide this latter predicate, V may simply check e
Query(r, s)τ,κ , say, on pack
t(r ∥ r′ ) · β(r)
= s.
e
We assume that κ is sufficiently small that V may evaluate β(r)
itself; on the other hand, V may ascertain
e
t(r ∥ r′ ) by means of one query to [t].
The shifting construction. We again write Tι ⊂ Tτ for a tower subfield, P
and fix an integer ℓ ∈ N. We
k−1
recall the identification which, for each k ∈ {0, . . . , ℓ}, maps v ∈ Bk to {v} := i=0 2i · vi .
For each block size parameter b ∈ {0, . . . , ℓ} and each shift offset o ∈ Bb , the shift operator, on input
t ∈ TιBℓ , partitions t’s index set Bℓ into b-dimensional subcubes, and then circularly rotates each resulting
sub-array by o steps (where we, implicitly, flatten each sub-array lexicographically). We make this precise
in the following way. For each b ∈ {0, . . . , ℓ} and o ∈ Bb as above, we define the shift mapping sb,o : Bℓ → Bℓ
by declaring, for each input v = (v0 , . . . , vℓ−1 ) ∈ Bℓ , that sb,o (v) := u, where u = (u0 , . . . , uℓ−1 ) is such
that the most-significant substrings (ub , . . . , uℓ−1 ) and (vb , . . . , vℓ−1 ) agree, and {u} + {o} ≡ {v} (mod 2b )
moreover holds. We define the shift operator shiftb,o : TιBℓ → TιBℓ by mapping each t ∈ TιBℓ to the vector
shiftb,o (t) := (t(sb,o (v)))v∈Bℓ . We note that, provided we flatten t and shiftb,o (t) using the lexicographic
Pℓ−1 i
identification v 7→
i=0 2 · vi , shiftb,o (t) has precisely the effect of circularly rotating each contiguous
2b -sized block of t downward by {o} steps.
We initiate an arithmetic characterization of the shift operator, which expresses each shifted vector
shiftb,o (t) as a virtual polynomial on its input t. In fact, our construction moreover admits a linear-time—
that is, a Θ(b)-time—evaluation algorithm, as we explain below. Our approach is inspired by, and generalizes,
the “adding 1 in binary” multilinear indicator of Setty, Thaler, and Wahby [STW23, § 5.1].
We first define the length-b, o-step shift indicator function s-indb,o : Bb × Bb → {0, 1}:
(
s-indb,o : (x, y) 7→

?

1

if {y} ≡ {x} + {o}

0

otherwise.

29

(mod 2b )

For b and (o0 , . . . , ob−1 ) = o ∈ Bb again fixed, we realize the shift indicator function s-indb,o inductively,
by means of a sequence of functions s-ind′k,o and s-ind′′k,o , each mapping Bk ×Bk → {0, 1}, for k ∈ {0, . . . , b}.
That is, for each k ∈ {0, . . . , b}, on arguments x and y in Bk , we define the function s-ind′k,o (x, y) so as
?

?

to detect the condition {y} = {x} + {o}, and define s-ind′′k,o (x, y) so as to detect the condition {y} =
{x} + {o} − 2k , where, in both expressions, we interpret o = (o0 , . . . , ok−1 ) as an element of Bk by truncating
its bits. In words, s-ind′k,o detects the condition whereby the k-bit strings x and y differ exactly by the binary
addition of o’s least-significant k bits, and without overflow no less; s-ind′′k,o detects the analogous condition,
modulo an overflow into the k th -indexed bit position. We finally note that s-indb,o := s-ind′b,o ∨ s-ind′′b,o .
We now present an inductive—and arithmetically friendly—description of the functions s-ind′k,o and
s-ind′′k,o , for k ∈ {0, . . . , b}. For typographical convenience, we give meaning to expressions of the form
s-ind′k−1,o (x, y) and s-ind′′k−1,o (x, y), for arguments x and y in Bk —i.e., rather than in the domain of
definition Bk−1 —by stipulating that the functions simply ignore their arguments’ respective most-significant
?
(that is, k−1-indexed) bits. Finally, below, we understand the expression xk−1 = ok−1 +yk−1 and its variants
over the integers (i.e., as integer expressions over the arguments xk−1 , yk−1 , and ok−1 in {0, 1} ⊂ Z).
case k = 0.
s-ind′0,o = 1.
s-ind′′0,o = 0.
case k > 0.
s-ind′k,o (x, y) =

s-ind′′k,o (x, y) =


′


s-indk−1,o (x, y)

?

if xk−1 + ok−1 = yk−1
?

s-ind′′k−1,o (x, y) if xk−1 + ok−1 + 1 = yk−1


0
otherwise.

?

s-ind′k−1,o (x, y) if xk−1 + ok−1 = yk−1 + 2

s-ind′′k−1,o (x, y)


0

?

if xk−1 + ok−1 + 1 = yk−1 + 2
otherwise.

The correctness of this inductive description may be explicitly checked. We note that s-indb,o (x, y) =
s-ind′b,o (x, y) + s-ind′′b,o (x, y) holds for each (x, y) ∈ Bb × Bb .
Exploiting the inductive description just given, we now arithmetically characterize the MLEs in
Tι [X0 , . . . , Xk−1 , Y0 , . . . , Yk−1 ]⪯1 of the shift-indicator functions s-ind′k,o and s-ind′′k,o .
case k ′= 0.
^ 0,o = 1.
s-ind
′′

^ 0,o = 0.
s-ind
case k > 0.

(
′
′′
^ k−1,o (X, Y ) + (1 − Xk−1 ) · Yk−1 · s-ind
^ k−1,o (X, Y )
e
fq(Xk−1 , Yk−1 ) · s-ind
′
^ k−1,o (X, Y )
(1 − Xk−1 ) · Yk−1 · s-ind
(
′′
^ k−1,o (X, Y )
′′
Xk−1 · (1 − Yk−1 ) · s-ind
^ k,o (X, Y ) =
s-ind
′
′′
^ k−1,o (X, Y ) + e
^ k−1,o (X, Y )
Xk−1 · (1 − Yk−1 ) · s-ind
fq(Xk−1 , Yk−1 ) · s-ind
′
^ k,o (X, Y ) =
s-ind

?

ok−1 = 0.
?

ok−1 = 1.
?

ok−1 = 0.
?

ok−1 = 1.

Above, we again make use of the multilinear equality function e
fq (see Subsection 2.1), which we apply here
′
′′
^ k−1,o and s-ind
^ k−1,o , upon
only to pairs of 1-bit arguments. We again stipulate that the functions s-ind
being fed k-variate arguments, simply ignore these arguments’ respective last variables.
′
′′
^ b,o := s-ind
^ b,o + s-ind
^ b,o .
Finally, we define s-ind
^ b,o ∈ Tι [X0 , . . . , Xb−1 , Y0 , . . . , Yb−1 ] just given is the MLE of s-indb,o .
Theorem 4.24. The polynomial s-ind

30

^ b,o ’s pointwise agreement with s-indb,o over Bb × Bb is self-evident. Its multilinProof. The function s-ind
′
′′
^ k,o and s-ind
^ k,o are sums
earity holds by induction; indeed, for each k ∈ {1, . . . , b}, we note that both s-ind
′

′′

^ k−1,o or s-ind
^ k−1,o , funcof products between some multilinear function of Xk−1 and Yk−1 and either s-ind
tions which themselves are—by induction—multilinear in the variables (X0 , . . . , Xk−2 , Y0 , . . . , Yk−2 ). Each
such product expression is necessarily multilinear in the variables (X0 , . . . , Xk−1 , Y0 , . . . , Yk−1 ).
^ b,o admits a Θ(b)-sized, layered arithmetic circuit; this circuit’s
We finally note that the polynomial s-ind
description arises straightforwardly from the function’s inductive characterization just given above.
We return to the shift operator shiftb,o : TιBℓ → TιBℓ already introduced. Leveraging the arithmetized
shift-indicator functions just treated, we now present an arithmetical description of shiftb,o . Indeed, for
each t ∈ TιBℓ and each v ∈ Bℓ , we have the equality:
X
shiftb,o (t)(v) =
t(u0 , . . . , ub−1 , vb , . . . , vℓ−1 ) · s-indb,o (u0 , . . . , ub−1 , v0 , . . . , vb−1 ).
u∈Bb

^ b,o (t)(X0 , . . . , Xℓ−1 ) ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 for the MLE of shiftb,o (t). We note the
Finally, we write shift
explicit expression:
X
e
^ b,o (t)(X0 , . . . , Xℓ−1 ) =
^ b,o (u0 , . . . , ub−1 , X0 , . . . , Xb−1 ).
shift
t(u0 , . . . , ub−1 , Xb , . . . , Xℓ−1 ) · s-ind
u∈Bb

Indeed, the polynomial above is clearly multilinear, and agrees pointwise with shiftb,o (t) over Bℓ .
^ b,o (t) defines a virtual polynomial, which we again claim is
When [t] is a handle, the expression shift
^ b,o (t)(r′ ) is itself the
efficiently evaluable. We fix a query Query(r′ , s′ )ι,ℓ . We note that the evaluation shift
sum, over the cube Bb , of the b-variate polynomial:

′
′
^ b,o (t, r′ )(Y0 , . . . , Yb−1 ) := e
^ b,o Y0 , . . . , Yb−1 , r0′ , . . . , rb−1
shift
t(Y0 , . . . , Yb−1 , rb′ , . . . , rℓ−1
) · s-ind
.
^ b,o (t, r′ ); using a sumcheck, V may in turn reduce this
It thus suffices for V to decide Sum(s′ )τ,b on shift
^ b,o (t, r′ ), for values r ∈ Tτb and s ∈ Tτ derived during the sumcheck. As
predicate to Query(r, s)τ,b on shift
′
before, V may decide this latter predicate itself, by querying t(r0 , . . . , rb−1 , rb′ , . . . , rℓ−1
) and locally evaluating
′
′
^
s-indb,o (r0 , . . . , rb−1 , r0 , . . . , rb−1 ).
We will occasionally find reason to insist on the nonexistence or the existence of an overflow. In these
cases, respectively, we may simply replace the shift-indicator function s-indb,o with its simpler analogues
s-ind′b,o and s-ind′′b,o , in the expression for shiftb,o above. We write shift′b,o and shift′′b,o for the resulting
overflow-free and overflow-mandated shift operators.
Example 4.25. We set ι := 0 and b := 5, and fix ℓ ≥ 5 and o := (o0 , . . . , o4 ) ∈ B5 arbitrarily. For each
vector t ∈ T0Bℓ —which we view as a length-2ℓ column of bits, by means of the lexicographic flattening
Pℓ−1
v 7→ i=0 2i · vi —the operator shiftb,o (t) breaks t into 32-elements chunks, and then circularly rotates
each chunk downwards by {o} steps (or equivalently, upward by 32 − {o} steps). On the other hand, the
overflow-free shift operator shift′b,o (t) rotates each chunk downwards by {o} steps, without rotation; that is,
it 0-fills the first {o} components of each chunk. Finally, the operator shift′′b,o (t) acts by upwardly shifting
t by 32 − {o} steps, 0-filling the bottom 32 − {o} elements of each chunk.
Remark 4.26. Our shift construction answers affirmatively a problem posed by HyperPlonk [CBBZ23]
(see p. 52 of the full version). Indeed, the construction [CBBZ23, Lem. 3.13] (that is, Lemma 3.9 of the
full version) yields a virtual polynomial which does something like a one-step circular rotation; specifically,
that construction’s permutation leaves the origin fixed, and rotates the rest of the vector in some—not
lexicographic—order (determined by the action of a multiplicative generator). Though that construction
can be iterated, the complexity of the iterated virtual polynomial grows exponentially in the number of
iterations (i.e., the number of rotation steps). Our shift construction, on the other hand, performs a true
circular rotation—that is, without a degenerate orbit at the origin—and moreover operates in lexicographic
order. Interestingly, our shift construction’s complexity is completely independent of the rotation offset.
Rather, our virtual polynomial grows only linearly in the block size; moreover, it admits an evaluation
protocol—which leverages the sumcheck—whose complexity grows just logarithmically in the block size.
31

The saturation construction. We record a final, and very simple, virtual polynomial construction, which
we use in our multiplication gadget below (see Subsection 5.3). For ℓ ≥ 0 fixed, and given block size and
offset parameters b ∈ {0, . . . , ℓ} and o ∈ Bb as above, the saturation operator, on input t ∈ TιBℓ , partitions t’s
index set Bℓ into b-dimensional subcubes, and “saturates” each resulting block with a single value (i.e., that
which t takes at the block’s oth position). More precisely, we define the saturation mapping rb,o : Bℓ → Bℓ
by setting rb,o (v0 , . . . , vℓ−1 ) := (o0 , . . . , ob−1 , vb , . . . , vℓ−1 ), for each v = (v0 , . . . , vℓ−1 ) ∈ Bℓ ; finally, we define
the saturation operator satb,o : TιBℓ → TιBℓ by setting satb,o (t) := (t(rb,o (v)))v∈Bℓ .
We record a virtual polynomial realization of the saturation operator. Indeed, for b ∈ {0, . . . , ℓ} and
o ∈ Bb as above, and for each t ∈ TιBℓ and v ∈ Bℓ , we have that:
satb,o (t)(v) = t(o0 , . . . , ob−1 , vb , . . . , vℓ−1 );
writing sg
atb,o (t) ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 for the MLE of satb,o (t), we conclude that:
sg
atb,o (t)(X0 , . . . , Xℓ−1 ) = e
t(o0 , . . . , ob−1 , Xb , . . . , Xℓ−1 ).
The polynomial above is clearly multilinear, and agrees pointwise with satb,o (t) over Bℓ .
When t is a virtual polynomial, sg
atb,o (t) clearly also is, and can be evaluated as efficiently as t can.

4.4

Binary-Field Lasso

In this subsection, we discuss the work Lasso of Setty, Thaler and Wahby [STW24] and adapt that work to
our binary tower setting.
We develop a distilled, conceptually minimal approach to Lasso, by teasing apart its various components.
Indeed, we contend that Lasso ultimately amounts to a combination of the following components:
• A virtual polynomial abstraction, which materializes large tables. Indeed, Lasso’s “SOS
tables” [STW24, § 4] can be viewed as composition virtual polynomials in the sense of Example 4.9
above, which, operating over subtables, virtually materialize large tables.
• A small-table lookup procedure. Lasso’s core contribution is, arguably, its single-table lookup
procedure [STW24, Lem. 3], a virtual polynomial protocol which—using offline memory-checking in
the sense of Blum et al. [Blu+91]—proves that the values taken over the cube by one virtual polynomial
represent a subset of the values taken over the cube by another virtual polynomial. More precisely,
Lasso’s lookup procedure reduces precisely this predicate to a multiset predicate on certain further
virtual polynomials.
• A multiset-check. Finally, Lasso employs a virtual protocol which securely decides the multiset
predicate [STW24, Lem. 4], in the sense already developed in Subsections 4.1 and 4.2 above.
Leveraging our abstractions, already developed above, for virtual polynomials and multisets, we thus
record a minimal rendition of Lasso, which, in particular, isolates its memory-checking component. Importantly, we excise the table-virtualization process from the jurisdiction of the lookup itself, and subsume
it into the constraint-satisfaction apparatus already furnished by our higher-level SNARK (see Section 5
below). This separation of concerns yields a conceptually simpler framework.
Separately, we adapt Lasso to the setting of binary fields. We note first of all that the key technical result
[STW24, Lem. 2] assumes that the field at hand of large prime characteristic (i.e., larger than the length of
the looked-up column). That restriction is moreover essential, in the sense that [STW24, Fig. 2] as written
becomes insecure in the small-characteristic setting. We adapt that work by introducing a multiplicative
version of it; that is, we stipulate that the prover and verifier jointly increment the protocol’s various
timestamps not by adding 1 to them, but rather by multiplying them by a multiplicative generator of an
appropriate binary field. Our multiplicative adaptation, however, introduces further complications. Indeed,
unlike the incrementation operation, the multiply-by-generator operation on a field induces an action which
is not transitive, but rather features a singleton orbit (at 0, of course). Since this fact too can be used to
attack the protocol, we must further require that the prover submit an everywhere-nonzero vector of read
counts. We achieve this guarantee in our treatment below, at the cost of requiring that the prover commit
to an additional polynomial (we discuss our remedy further in Remark 4.29 below).
V
We now record our protocol for the lookup predicate Lookupι,ℓ : (T, U ) 7→ v∈Bℓ ∃v ′ ∈ Bℓ : U (v) = T (v ′ ).
32

PROTOCOL 4.27 (Lasso-based lookup [STW24]).
Parameters ι and ℓ in N, and ℓ-variate virtual polynomials [T ] and [U ] over Tι , are fixed.
• P and V set ζ ≥ 0 minimally so that |Tζ | − 1 > 2ℓ holds (equivalently, they set ζ := ⌈log(ℓ + 1)⌉);
P and V moreover fix a generator α ∈ Tζ∗ of Tζ ’s multiplicative group of units Tζ∗ .
• P defines arrays R and F in TζBℓ as follows. P initializes F := (1)v∈Bℓ , and then executes:
1: for each v ∈ Bℓ , in any order, do
2:
pick an arbitrary v ′ ∈ Bℓ for which U (v) = T (v ′ ) holds.
3:
assign R[v] := F [v ′ ].
4:
overwrite F [v ′ ] ×= α.


1
to be the pointwise reciprocal of the vector R. P submits the multilinear
P sets R′ := R(v)
v∈Bℓ

 



e , submit, ζ, ℓ, R
f′ , and submit, ζ, ℓ, Fe to the oracle.
extensions submit, ζ, ℓ, R
• P and V run a zerocheck on the ℓ-variate virtual polynomial R · R′ − 1 over Tζ .
• P and V define further ℓ-variate virtual polynomials as follows. They set O : (X0 , . . . , Xℓ−1 ) 7→ 1
to be the identically-1 polynomial, and set W := α · R. P and V finally run a 4-ary multiset check
on the ℓ + 1-variate pairs (merge(T, U ), merge(O, W )) and (merge(T, U ), merge(F, R)).
Above, our F corresponds to Lasso’s array of “final counts”, R correspond to its array of inline read counts,
and W corresponds to its array of inline write counts. We refer to [STW24, Lem. 3]. Protocol 4.27’s
completeness amounts to a more-or-less straightforward, albeit subtle exercise, and essentially follows from
[STW24, Lem. 2]. We suggest the following inductive proof. Indeed, assuming that R is initialized to the
all-zero array (0)v∈Bℓ , we argue that the equality
{(T (v), 1) | v ∈ Bℓ } ∪ {(U (v), α · R(v)) | v ∈ Bℓ } = {(T (v), F (v)) | v ∈ Bℓ } ∪ {(U (v), R(v)) | v ∈ Bℓ }

(2)

of multisets is an algorithmic invariant of the main loop above (that is, it holds as of the beginning of each
iteration). The base case is clear (both multisets at hand equal {(T (v), 1) | v ∈ Bℓ } ∪ {(U (v), 0) | v ∈ Bℓ }).
We fix an iteration index v ∈ Bℓ of the above loop. The assignment 3 entails removing (U (v), 0) from both
multisets, as well as adding (U (v), α · F [v ′ ]) to the left multiset and (U (v), F [v ′ ]) to the right. On the other
hand, the update 4 entails removing (T (v ′ ), F [v ′ ]) from the right multiset and adding (T (v ′ ), α · F [v ′ ]) to
the right multiset. Since T (v ′ ) = U (v), these changes balance; assuming that the equality held at the loop’s
beginning, we conclude that it likewise holds as of the loop’s end. This completes the proof of completeness.
Theorem 4.28. Protocol 4.27 securely decides the predicate Lookupι,ℓ on [T ] and [U ].
Proof. We adapt Setty, Thaler, and Wahby [STW24, Lem. 3] to the multiplicative setting. Assuming that
Zeroζ,ℓ (R · R′ − 1) = 1 and Multiset(4)τ,ℓ+1 (merge(T, U ), merge(O, W ), merge(T, U ), merge(F, R)) = 1 both
hold, we show that Lookupι,ℓ (T, U ) = 1 holds with probability 1. Our assumption Zeroζ,ℓ (R · R′ − 1) = 1
immediately implies that, for each v ∈ Bℓ , R(v) · R′ (v) = 1, so that R(v) ̸= 0. Our second assumption is
precisely the equality (2) of multisets. From it, we conclude a fortiori that
{(U (v), R(v)) | v ∈ Bℓ } ⊂ {(T (v), 1) | v ∈ Bℓ } ∪ {(U (v), α · R(v)) | v ∈ Bℓ }

(3)

as multisets. We suppose, for contradiction, that v0 ∈ Bℓ , say, were such that, for each v ′ ∈ Bℓ , U (v0 ) ̸= T (v ′ )
held. Our hypothesis on v0 implies that (U (v0 ), R(v0 )) ̸∈ {(T (v), 1) | v ∈ Bℓ }; we thus conclude from (3) that
(U (v0 ), R(v0 )) ∈ {(U (v), α · R(v)) | v ∈ Bℓ }, so that v1 ∈ Bℓ , say, is such that (U (v0 ), R(v0 )) = (U (v1 ), α ·
R(v1 )). Since U (v1 ) = U (v2 ), applying (3) again to the pair (U (v1 ), R(v1 )), we find as before an element
v2 ∈ Bℓ , say, for which (U (v1 ), R(v1 )) = (U (v2 ), α · R(v2 )). Proceeding in this way, we obtain a sequence of
elements vi ∈ Bℓ , for i ∈ {0, . . . , 2ℓ }, for which, for each i ∈ {0, . . . , 2ℓ − 1}, R(vi+1 ) · α = R(vi ) holds. Since
|Bℓ | = 2ℓ , by the pigeonhole principle, we must have a collision vi = vj , for unequal indices i < j, say, in
{0, . . . , 2ℓ }. We conclude that R(vi ) = αj−i ·R(vj ) = αj−i ·R(vi ); using our guarantee whereby R(vi ) ̸= 0, we
finally conclude that αj−i = 1. Since j − i ∈ {1, . . . , 2ℓ }, and α’s multiplicative order is exactly |Tζ | − 1 > 2ℓ ,
we obtain a contradiction. We conclude that Lookupι,ℓ (T, U ) = 1, as desired.
33

Remark 4.29. The naı̈ve multiplicative adaptation of Spark [STW24, Fig. 2] would neglect to include the
pointwise reciprocal R′ in Protocol 4.27 above. We argue that this reciprocal is necessary by exhibiting an
attack on this simpler variant of Protocol 4.27 (i.e., that which omits R′ ). (In other words, the everywherenonvanishing of R—used in our proof of Theorem 4.28 above—is essential.) Indeed, to attack that protocol, P
may, on an arbitrarily chosen statement U , simply set R identically zero and F identically 1. Having begun
in this way, and otherwise proceeding honestly (i.e., in the multiset check), P will convince the verifier.
Indeed, we see directly that, in this setting, W will likewise be identically zero, and that the equality (2) of
multisets will hold. This attack’s root cause is that the element 0 ∈ Tζ constitutes a degenerate orbit—of size
1—under the multiplicative α-action on Tζ . The pairs (U (v), 0) and (U (v), α · 0) thus balance the right and
left multisets, respectively, regardless of U (v) (i.e., regardless of whether it equals T (v ′ ) for some v ′ ∈ Bℓ ).

5

A SNARK over Binary Tower Fields

We now present a practical SNARK, suitable for general statements over binary tower fields. Its arithmetization scheme—that is, the method by which it algebraically captures general computations—refines the
PLONKish scheme of Grigg, Bowe, Hopwood and Lai [GBHL22], and in particular its adaptation, due to
Chen, Bünz, Boneh and Zhang’s HyperPlonk [CBBZ23, Def. 4.1], to the multivariate setting. The PLONKish
arithmetization arranges its witness data into a computational trace, called a trace matrix, of field elements.
The scheme moreover makes use of a plurality of gate constraints; these are multivariate polynomials, to be
evaluated over the rows of the trace matrix.

5.1

The PLONK relation

We define the indexed relation RPLONK on tuples of the form (i, x; w). The index i captures the public
parameters of the constraint system, the statement x represents the circuit’s public inputs, and the witness
w includes further inputs to the circuit.
The index is defined to be a tuple of the form i = (τ, ℓ, ξ, nφ , nψ , ι, a, g, σ), where:
• τ ∈ N is the height of the maximally-indexed tower step Tτ in use,
• ℓ ∈ N is the base-2 logarithm of the number of trace rows (we require ℓ ≤ 2τ ),
• ξ ∈ {0, . . . , ℓ} is the base-2 logarithm of the statement length,
• nφ ∈ N is the number of fixed columns,
• nψ ∈ N is the number of witness columns,
• ι : {0, . . . , nψ − 1} → {0, . . . , τ } is a mapping, which assigns to each witness column a tower field index,
 nφ
• a ∈ TτBℓ
is the array of fixed columns,
• (g0 , . . . , gµ−1 ) is a list of ℓ-variate virtual polynomials, each of which operates over nφ + nψ handles,
• σ : {0, . . . , nφ + nψ } × Bℓ → {0, . . . , nφ + nψ } × Bℓ defines a plurality of global copy constraints.
n
B
The statement is x := x ∈ Tτ ξ , a vector of input values. The witness is w := w ∈ TτBℓ ψ , an array of
witness columns.
We record several remarks. We assume throughout that τ is sufficiently large that an injection s :
{0, . . . , nφ + nψ } × Bℓ ,→ Tτ exists. Above, we slightly abuse notation by calling the objects (g0 , . . . , gµ−1 )
“virtual polynomials”; more properly, these are circuits which operate over “placeholder” handles (i.e.,
handles which don’t exist yet). Once the relevant handles become available—i.e., after the indexer and prover
commit to the fixed and witness columns, respectively—the verifier may, by “plugging in” the appropriate
handles, create from each of these circuits a genuine virtual polynomial. On the other hand, upon being fed
real polynomials (as opposed to handles), these virtual polynomials of course become standard polynomials.
B
For convenience, we write padℓ (x) ∈ TτBℓ for the zero-extension of the vector x ∈ Tτ ξ to the domain Bℓ ;

n
+n
φ
ψ
we moreover write c ∈ TτBℓ
for the concatenation of columns c := a ∥ w ∥ padℓ (x). The indexed
relation RPLONK holds, by definition, if and only if:
34


1. For each i ∈ {0, . . . , µ − 1}, the polynomial gi c0 , . . . , cnφ +nψ −1 is identically zero over Bℓ .
2. For each (i, v) ∈ {0, . . . , nφ + nψ } × Bℓ , it holds that ci (v) = ci′ (v ′ ), where we write (i′ , v ′ ) := σ(i, v).
3. For each (i, v) ∈ {0, . . . , nψ − 1} × Bℓ , it holds that wi (v) ∈ Tι(i) ⊂ Tτ .
These three conditions capture, respectively, the witness’s satisfaction of all gate constraints, its satisfaction of all global copy constraints, and finally its satisfaction of all subfield constraints. The first two
conditions are standard across PLONKish variants (see e.g. [CBBZ23, Def. 4.1]); the third condition is new,
and pertains specifically to our tower setting. We note that we do not isolate so-called selector columns, as
prior formalizations do (see e.g. [CBBZ23, Sec. 4.1] and [STW23, Sec. 2.2]); instead, we subsume these into
our fixed columns a.

5.2

Top-Level Protocol

We now present a tower field multilinear polynomial IOP for the indexed relation RPLONK . On the input i,
the indexer I, for each i ∈ {0, . . . , nφ − 1}, submits (submit, τ, ℓ, aei ) to the oracle, where aei is the MLE of the
fixed column ai ∈ TτBℓ , and receives (receipt, τ, ℓ, [ai ]). Moreover, I performs the permutation check’s setup
procedure—already described in detail in advance of Protocol 4.22 above—with respect to the permutation
σ : {0, . . . , nφ + nψ } × Bℓ → {0, . . . , nφ + nψ } × Bℓ ; in this way, I obtains
further handles [sid ] and [sσ ].

Finally, I outputs the list of handles vp := [a0 ], . . . , [anφ −1 ], [sid ], [sσ ] .
PROTOCOL 5.1 (main polynomial IOP for RPLONK ).
On the security parameter λ, and common input i and x, P and V proceed as follows.
• Both P and V compute the zero-extension padℓ (cι ), as well as its MLE pg
adℓ (cι ).
• For each i ∈ {0, . . . , nψ − 1}, P sends (submit, ι(i), ℓ, wi ) to the polynomial oracle.
?

• For each i ∈ {0, . . . , nψ −1}, upon receiving (receipt, ιi , ℓ, [wi ]) from the oracle, V checks ιi = ι(i).


We abbreviate [c0 ], . . . , [cnφ +nψ −1 ] := [a0 ], . . . , [anφ −1 ], [w0 ], . . . , [wnψ −1 ] .

• For each i ∈ {0, . . . , µ − 1}, P and V zerocheck the virtual polynomial gi [c0 ], . . . , [cnφ +nψ −1 ] .

• P and V run a permutation check, with statement σ, on the input [c0 ], . . . , [cnφ +nψ ] .
Theorem 5.2. Protocol 5.1 securely computes the relation RPLONK .
Proof. We construct an emulator E. Our emulator E operates as follows, given access to A, and to i and x:
1. E independently runs vp := I(i), internally simulating the existence of the polynomial oracle.
2. Using vp, and playing the role of V, E runs A internally, and in particular intercepts its submissions
(submit, ιi , ℓ, wi ) intended for the polynomial oracle. As V would, E aborts if, for any index i ∈
{0, . . . , nψ − 1}, either A fails to submit the expected witness wi or the tower height ιi ̸= ι(i) is wrong.
3. E continues to simulate the role of V internally to A, during the course of the virtual protocols prescribed
by Protocol 5.1. If, at any point, the verifier V in E’s head aborts, then E does too (i.e., it outputs ⊥).

4. E outputs w := w0 , . . . , wnψ −1 and terminates.
We argue that E fulfills the requirements of Definition 4.3 with respect to the relation RPLONK . We note
first that E outputs w in step 4 above with the same probability with which V accepts. It follows that the
relevant discrepancy |Pr[⟨A(i, x), V(vp, x)⟩ = 1] − Pr[R(i, x, w) = 1]| is equal to the probability with which
A submits a well-formed witness w for which R(i, x, w) = 0 holds and V nonetheless accepts. This latter
probability is negligible precisely in virtue of the security—in the sense of Definition 4.7—of the zerocheck
and permutation check virtual protocols which V runs with A in Protocol 5.1.
35

5.3

Gadgets

In this subsection, we record composable gadgets for various key operations, including unsigned integer
addition and multiplication. In our setting, a “gadget” is a special sort of virtual polynomial protocol
in which the predicate at hand may apply not just to input columns—that is, to polynomials known to
both parties before the protocol begins—but moreover to further virtual polynomials which arise during the
protocol. Informally, a gadget is a virtual protocol in which, if the verifier doesn’t abort, the parties output
a further virtual polynomial, which necessarily relates to the protocol’s inputs in a prescribed way. This
slight relaxation of Definition 4.7 doesn’t change the spirit of that definition.
Addition. We record a simple gadget for the addition of unsigned integers. Our construction, informally,
captures the raw relationship at the level of bits, using a few simple F2 -constraints, as well as a shift (see
Subsection 4.3); it then uses the packing operator to materialize the relevant bit-columns into virtual columns
of blocks.
We fix a column size ℓ ≥ 0 and a bit-width b ∈ {0, . . . , ℓ}. On inputs X, Y , and Z in T0Bℓ , the addition
V
b
predicate sends Addℓ,b : (X, Y, Z) 7→ v∈Bℓ−b {packb (X)(v)} + {packb (Y )(v)} ≡ {packb (Z)(v)} (mod 22 ).
That is, the addition predicate requires that, for each v ∈ Bℓ−b , the elements packb (X)(v), packb (Y )(v), and
packb (Z)(v) of Tb respectively have monomial basis representations x = (x0 , . . . , x2b −1 ), y = (z0 , . . . , z2b −1 ),
P2b −1
b
and z = (z0 , . . . , z2b −1 ) for which {x} + {y} ≡ {z} (mod 22 ) holds (as usual, we write {v} := i=0 2i · vi ).
PROTOCOL 5.3 (Addition gadget).
Parameters ℓ ∈ N and b ∈ {0, . . . , ℓ} and ℓ-variate virtual polynomials [X] and [Y ] over T0 are fixed.
• By performing 2ℓ−b independent 2b -bit ripple-carry additions, P obtains the vector of carry-outs
cout ∈ T0Bℓ . P submits (submit, 0, ℓ, cg
out ) to the oracle.
• P and V define ℓ-variate virtual polynomials cin := shift′b,1 (cout ) and Z := X + Y + cin over T0 .
• P and V zerocheck the ℓ-variate virtual polynomial X · Y + X · cin + Y · cin − cout over T0 .
• P and V output Z.
Theorem 5.4. Protocol 5.3 securely decides the predicate Addℓ,b on [X], [Y ] and [Z].
Proof. Indeed, assuming that Zero0,ℓ (X · Y + X · cin + Y · cin − cout ) = 1, we show that Addℓ,b (X, Y, Z)
holds with probability 1. Protocol 5.3 captures the action of a ripple-carry adder on each 2b -bit chunk of the
inputs X and Y . Indeed, our hypothesis entails exactly that the F2 -identity X · Y + X · cin + Y · cin = cout
holds identically over Bℓ . This shows that, logically, cout = X ∧ Y ∨ X ∧ cin ∨ Y ∧ cin holds identically over
Bℓ , so that cout relates as required to X, Y and cin . On the other hand, the relationship between cin and
cout is correct, by definition of shift′b,1 . We conclude that Z := X + Y + cin has the required property.
Multiplication. We now describe a gadget which captures unsigned integer multiplication.
For each
V
ℓ ≥ 0 and b ∈ {0, . . . , ℓ}, we define the multiplication predicate Multℓ,b (X, Y, Z) 7→ v∈Bℓ−b {packb (X)(v)} ·
b

{packb (Y )(v)} ≡ {packb (Z)(v)} (mod 22 ).
Informally, our multiplication gadget executes the schoolbook algorithm on a-bit words, where a, a
tunable parameter, controls the size of a certain lookup table. We check the relevant word-by-word multiplications using lookups; the remaining work amounts to appropriately combining the results of the various
word-wise multiplications.
We fix a lookup table size parameter a ∈ {0, . . . , b−1}. We recall the multilinear Ta -basis 1, Xa , Xa+1 , Xa ·
B2a ×B2a
Xa+1 of Ta+2 . We define the multiplication lookup table T ∈ Ta+2
as follows:
T : (x, y) 7→ x · 1 + y · Xa + z0 (x, y) · Xa+1 + z1 (x, y) · Xa · Xa+1 .
Above, we first identify the B2a -elements x and y with Ta -elements, by means of the multilinear F2 -basis of
a
Ta . Moreover, we write z0 (x, y) and z1 (x, y) for the unique Ta -elements for which {z0 (x, y)}+22 ·{z1 (x, y)} =
36

{x} · {y} holds; here, the right-hand quantity is a simple product of integers. In words, z0 (x, y) and z1 (x, y),
on the level of bits, respectively give the lower and upper halves of the 2 · 2a -bit integer product {x} · {y}.
Informally, the lookup table T takes, as its values over the 2a + 2a -dimensional hypercube, precisely the
concatenations x ∥ y ∥ x · y of the “legal” multiplication triples (this concatenation takes place in Ta+2 ).
We how have the following virtual polynomial protocol:
PROTOCOL 5.5 (Multiplication gadget).
B2a+1
Parameters ℓ ∈ N, b ∈ {0, . . . , ℓ}, and a ∈ {0, . . . , b − 1}, as above, the lookup table T ∈ Ta+2
, and
finally ℓ-variate virtual polynomials [X] and [Y ] over T0 are fixed.
• P and V initialize the identically-zero ℓ-variate virtual column [Z] over T0 .
• For each u ∈ Bb−a , P and V proceed as follows:
– P and V abbreviate Xu := shift′b−a,u (packa (X)) and Yu := satb−a,u (packa (Y )).
B

ℓ−a
– P constructs the array crossu := (z0 (Xu (v), Yu (v)) + z1 (Xu (v), Yu (v)) · Xa )v∈Bℓ−a in Ta+1
,
where z0 and z1 are as above, and submits (submit, a + 1, ℓ − a, c^
rossu ) to the oracle.

– P and V perform a lookup on Uu := Xu · 1 + Yu · Xa + crossu · Xa+1 against T .
– For each parity bit j ∈ {0, 1}, P defines auxu,j ∈ T0Bℓ by concatenating the bits of
the 2ℓ−a−1 Ta+1 -elements of the substring (crossu (j, v1 , . . . , vℓ−a−1 ))v∈Bℓ−a−1 . P submits
g 0 ) and (submit, 0, ℓ, aux
g 1 ) to the oracle. P and V run a zerocheck on the
(submit, 0, ℓ, aux
ℓ − a-variate polynomial merge packa+1 (auxu,0 ), packa+1 (auxu,1 ) − crossu over Ta+1 .
– By running the addition gadget twice, each time with block parameter b, P and V update
Z += auxu,0 + shift′b,2a (auxu,1 ).
• P and V output the virtual polynomial [Z].
In the last line of the main loop, we slightly abuse notation by writing shift′b,2a to mean shift′b,o , where
o := (0, . . . , 0, 1, 0, . . . , 0) (i.e., {o} = 2a ).
| {z }
a zeros

The completeness of Protocol 5.5 is a straightforward, though delicate, exercise. We note that, for
each u ∈ Bb−a , the elements aux0 and aux1 of T0Bℓ are defined precisely so that packa+1 (auxu,0 ) and
packa+1 (auxu,1 ) respectively yield the even
 and odd substrings of crossu . In other words, the equality
merge packa+1 (auxu,0 ), packa+1 (auxu,1 ) = crossu ensured during the zerocheck holds essentially by fiat.
The completeness of the lookups follows directly from the construction of crossu .
Theorem 5.6. Protocol 5.5 securely decides the predicate Multℓ,b on [X], [Y ] and [Z].
Proof. If V accepts, then Lookup(T, Uu ) = 1 holds for
for each u ∈ Bb−a and
n each u ∈ Bb−a ; in particular,
o
each v ∈ Bℓ−a , we have the equality {crossu (v)} = shift′b−a,u (packa (X))(v) · {satb−a,u (packa (Y ))(v)}

of unsigned, 2a+1 -bit integers. Unwinding the definitions of shift′b−a,u and satb−a,u , we conclude further that, for each iteration u ∈ Bb−a as above and each chunk index (vb−a , . . . , vℓ−a−1 ), the vector
crossu , restricted to the chunk indexed by (vb−a , . . . , vℓ−a−1 ), contains exactly the 2b−a double-width cross
terms {packa (X)(s0 , . . . , sb−a−1 , vb−a , . . . , vℓ−a−1 )} · {packa (Y )(u0 , . . . , ub−a−1 , vb−a , . . . , vℓ−a−1 )}, where

the strings s := (s0 , . . . , sb−a−1 ) are such that {s} ranges through the list 0, . . . , 0, 1, 2, . . . , 2b−a − 1 − {u} .
In words, (crossu (w0 , . . . , wb−a−1 , vb−a , . . . , vℓ−a ))w∈Bb−a yields precisely the {u}th row of the triangular
array associated with the schoolbook multiplication of (packa (X)(w0 , . . . , wb−a−1 , vb−a , . . . , vℓ−a−1 ))w∈Bb−a
and (packa (Y )(w0 , . . . , wb−a−1 , vb−a , . . . , vℓ−a−1 ))w∈Bb−a , which we understand 2b−a -limb integers. Each cell
of this array, moreover, is double-width—that is, 2a+1 bits—and needs to be reduced.
b
To “fold” the elements of this row, with carries, we use a trick. Working modulo 22 , we must add
b−a a+1
the 2
2 -bit elements of each chunk of crossu , after shifting each successive element moreover by 2a
further positions (and truncating the most-significant 2a bits of the last-indexed element in each chunk).

37

Upon writing each integer in its proper place, we find that the even-indexed components of the chunk—
corresponding to those indices (0, w1 , . . . , wb−a−1 , vb−a , . . . , vℓ−a−1 ), for (w1 , . . . , wb−a−1 ) ∈ Bb−a−1 —don’t
overlap; the odd-indexed components (1, w1 , . . . , wb−a−1 , vb−a , . . . , vℓ−a−1 ) similarly lack overlaps. We thus
“lift” both of these respective substrings to bit-vectors, so that we can add them. The bit-vectors auxu,0
and auxu,1 , we see, are defined to be the respective lifts to T0Bℓ of the even and odd substrings of crossu ;
the verifier’s zerocheck ensures that they takePexactly this form. It thus remains only to show that, for each
block index (vb−a , . . . , vℓ−a−1 ), we have that w∈Bb−a 2{w}·a · {crossu (w0 , . . . , wb−a−1 , vb−a , . . . , vℓ−a−1 )} ≡
n
o n


o
b
packb (auxu,0 )(vb−a , . . . , vℓ−a−1 ) + packb shift′b,2a (auxu,1 ) (vb−a , . . . , vℓ−a−1 ) (mod 22 ). We observe finally that the two terms on this expression’s right-hand side correspond precisely to its left-hand
sum’s even-indexed and odd-indexed subset sums. This completes the proof.
We finally remark upon the efficiency of Protocol 5.5. Protocol 5.5 entails O(2b−a ) executions of the
a+1
addition gadget, as well as 2b−a lookups, each into tables T and Uu sized 22
and 2ℓ−a , respectively. The
parameter a ∈ {0, . . . , b − 1}, we see, mediates a tradeoff between more lookups and more expensive lookups;
those choices of a for which these costs become similar appear to be the best.
Example 5.7. In the case ℓ := 20 and b := 5, Protocol 5.5 yields a multiplication gadget for 32-bit integers.
3+1
Setting a := 3, we obtain a limb size of 23 = 8 bits, as well as a lookup table T —of size 22
= 216 —which
contains all possible byte-by-byte products. Finally, each looked-up column Uu is of size 220−3 = 217 . These
sizes thus all-but balance, and seem to be optimal. In this setting, we see that Protocol 5.5 proceeds by
performing the schoolbook method, chunk-wise, on pairs of 4-limb integers, using lookups to handle each
individual product of bytes.
Remark 5.8. Protocol 5.5 works only for those limb size parameters a strictly smaller than the block
size parameter b. In words, it requires that strictly more than one limb-by-limb product be performed
throughout the course of each 2b -bit integer product. While a variant of Protocol 5.5 adapted to the extreme
case a = b—that is, to the case of “one-shot” lookup-based products—should be possible (and in fact, should
be somewhat simpler than that which we give), the tables therein required would be impracticably large
b+1
in most interesting parameter regimes. (Specifically, they would be of size 22 ; we refer to Example 5.7
above.) We have opted not to pursue this line of inquiry.

5.4

Keccak-256 Arithmetization

In this subsection, we supply a PLONKish arithmetization (in the sense of Subsection 5.1 above) of the
Keccak-f [1600] permutation [BDPV11, § 1.2], which resides at the heart of the Keccak family of sponge
functions. The Keccak-256 hash function in particular represents a core bottleneck facing modern efforts to
scale Ethereum using SNARKs. Our arithmetization captures the correct computation of Keccak-f [1600],
and exploits the unique advantages of our tower-field setting.
We recall the full Keccak-f [b] permutation. We follow the treatment of that algorithm given in
[BDPV11, § 1.2], as well as a pseudocode description given online. The permutation state consists of a
b-bit-array A ∈ F5×5×w
, where w := 2ℓ for some power ℓ ∈ {0, . . . , 6} (below, we in fact fix ℓ := 6, so
2
that b = 1600). We understand A throughout as a 5 × 5 array of lanes, or w-bit words (see [BDPV11,
Fig. 1.1]), and index into it accordingly. We define addition and multiplication on lanes componentwise; to
avoid confusion, we denote using the symbol ∗ the componentwise multiplication of lanes (i.e., the bitwise
AND operation). The intermediate value B below takes the same shape as A does; the objects C and D
below are one-dimensional, length-5 arrays of lanes. We understand all indices into these arrays modulo
5. We moreover make use of various constants. That is, we have a number nr of rounds (per Keccak’s
specification, we set nr := 12 + 2 · ℓ = 24); as well as a 5 × 5 array r ∈ {0, . . . , w − 1}5×5 of rotation offsets,
whose derivation is explained in [BDPV11, § 1.2]. We finally have an array RC of round constants, whose
construction is again detailed in [BDPV11, § 1.2]; for each ir ∈ {0, . . . , nr − 1}, RC[ir ] ∈ Fw
2 is a single binary
word. We reproduce the Keccak-f [b] permutation in full in Algorithm 1 below.

38

Algorithm 1 (Keccak-f [b] permutation [BDPV11].)
1: procedure Keccak-f [b](A)
2:
for ir ∈ {0, . . . , nr − 1} do
3:
for x ∈ {0, . . . , 4} do C[x] := A[x, 0] + A[x, 1] + A[x, 2] + A[x, 3] + A[x, 4].
4:
for x ∈ {0, . . . , 4} do D[x] := C[x − 1] + rot(C[x + 1], 1).
5:
for (x, y) ∈ {0, . . . , 4} × {0, . . . , 4} do A[x, y] += D[x].
6:
for (x, y) ∈ {0, . . . , 4} × {0, . . . , 4} do B[y, 2 · x + 3 · y] := rot(A[x, y], r[x, y]).
7:
for (x, y) ∈ {0, . . . , 4} × {0, . . . , 4} do A[x, y] = (B[x + 1, y] + 1) ∗ B[x + 2, y].
8:
A[0, 0] += RC[ir ].

▷ begin θ step

▷ γ and π steps
▷ χ step
▷ ι step

We build our PLONK constraint system for Keccak-f [1600] over two tower fields, T0 and T6 . We
take the liberty of defining the constraint system over committed columns of different lengths, linking them
by means of a packing argument (see Subsection 4.3). The constraint system has 25 rows, so that it can
accommodate nr = 24 rounds; it uses one row per round. It uses two fixed columns:
• qround ∈ T0 [X0 , ..., X4 ]⪯1 is the selector for the round computation. It takes the value 1 on those cube
points lexicographically indexed {0, . . . , 23} and 0 on the points indexed {24, . . . , 31}. This polynomial
has a simple description as a multilinear extension over the dimension-5 cube, and so can be efficiently
evaluated locally by the verifier (i.e., without the aid of a commitment or an opening proof).
• RC ∈ T6 [X0 , ..., X4 ]⪯1 is the column of 64-bit round constants.
The permutation state is committed in the following group of columns:
5×5
• A ∈ T0 [X0 , ..., X10 ]⪯1
captures the 25 lanes of state, as of the beginning of each successive round.

5
• C ∈ T0 [X0 , ..., X10 ]⪯1 represents C in the θ step above.
5
• D ∈ T0 [X0 , ..., X10 ]⪯1 represents D in the θ step above.
5×5
• Aχ ∈ T0 [X0 , ..., X10 ]⪯1
captures the state of A as of the conclusion of the χ step.
We further define a series of virtual polynomials:
5×5
• Aθ ∈ T0 [X0 , ..., X10 ]⪯1
represents the state of A as of the conclusion of the θ step. For each
x ∈ {0, . . . , 4} and y ∈ {0, . . . , 4}, we define Aθx,y := Ax,y + Dx .
5×5
• B ∈ T0 [X0 , ..., X10 ]⪯1
represents the state of B as of the conclusion of the π and γ steps. For
each x ∈ {0, . . . , 4} and y ∈ {0, . . . , 4}, we define By,2x+3y := shift6,r(x,y) (Aθx,y ).
We impose the following gate constraints:
P4
• For each x ∈ {0, ..., 4}, Cx − y=0 Ax,y = 0.
• For each x ∈ {0, ..., 4}, Cx−1 + shift6,1 (Cx+1 ) − Dx = 0.
• For each (x, y) ∈ {0, ..., 4} × {0, ..., 4}, Aχx,y − ((1 − Bx+1,y ) · Bx+2,y ) = 0.


• qround · pack6 Aχ0,0 + RC − shift′′5,−1 (pack6 (A0,0 )) = 0.

• For each (x, y) ∈ {0, ..., 4} × {0, ..., 4} \ {(0, 0)}, qround · shift′′5,−1 (pack6 (Ax,y )) − pack6 (Aχx,y ) = 0.
Provided that these constraints are fulfilled, the arrays (pack6 (Ax,y )(v))(x,y)∈{0,...,4}×{0,...,4} , for the rowindices {v} = 0 and {v} = 24 respectively, are related exactly by the Keccak-f [1600] permutation.

39

6

Performance Evaluation

We describe this work’s concrete performance, leveraging Binius, an open-source production-grade Rust
implementation of our protocol.
We begin by benchmarking our protocol’s polynomial commitment and sumcheck tasks, which jointly
dominate our prover’s overall computation. We further benchmark our protocol’s end-to-end performance
on the Keccak-f task, which entails proving the validity of a plurality of independent invocations of the
Keccak-f [1600] permutation (see Subsection 5.4 above). This task represents a critical subroutine in
SNARKs which prove the validity of Ethereum blocks. Our protocol beats the state-of-the-art in both of
these tasks, as we demonstrate in our tables below.
Binius of course implements the requisite tower field arithmetic primitives. We use the Intel Galois
Field New Instructions (GFNI) instruction set extension to accelerate the Wiedemann tower’s fundamental
multiplication and inversion operations. The GFNI extension includes the SIMD instruction GF2P8MULB,
which multiplies elements of the field F28 ∼
= F2 [X]/(X 8 + X 4 + X 3 + X + 1). This latter instruction assumes
a monomial—as opposed to a tower—F2 -basis of F28 ; we convert between these representations using the
further instruction GF2P8AFFINEQB. That is, by using these instructions together, we obtain a short sequence
of CPU instructions which multiplies F28 -elements expressed in coordinates with respect to the multilinear
basis. For those towers Tι for which ι > 3, we use the binary, recursive Karatsuba approach discussed above
(see Subsection 2.3), though we terminate its recursion at the base case ι = 3.
We benchmark our polynomial commitment scheme’s performance on polynomials over 1-bit, 8-bit, and
32-bit binary fields. The scheme of Subsection 3.4 works with any collision-resistant hash function; we instantiate that scheme with Grøstl, which—as has been explained above—is both performant and recursionfriendly. We use the Reed–Solomon code with rate 41 throughout. We present benchmarks for both singlethreaded execution (in Table 2) and multithreaded execution (in Table 3).
We benchmark our protocol against two high-performance software implementations of alternative
schemes. First, we benchmark against the Lasso open-source project’s implementation of Wahby et al.’s
Hyrax [Wah+18], using the BN254 elliptic curve. The latter library uses the well-known arkworks project
[ark22], as well as certain further optimizations specific to the commitment of small-valued field elements.
The Lasso project makes efficient use of multithreading during its commitment phase. We further benchmark
against Plonky3 , which implements FRI-PCS, itself parameterized so as to attain 100 bits of provable security (in the unique decoding regime). Though Plonky3’s FRI-PCS is univariate—while the other schemes we
benchmark here are multilinear—we find our comparison against it informative, in view of its highly-regarded
performance. Like our construction, FRI-PCS can be used with any collision-resistant hash function, as well
as with Reed–Solomon codes of arbitrary rate. We thus benchmark that scheme under both the Poseidon and
Keccak-256 hash functions; we note that Poseidon, though slower, is often used in practice for its recursionfriendliness. We moreover use the rate- 12 Reed–Solomon code, to match that used in our benchmarks of our
own construction. Plonky3 also implements multithreading, but performs best on batched polynomial commitments (as opposed to on single polynomial commitments). To present a fairer comparison, we specialize
that scheme to the batched case during both commitment and evaluation. Specifically, we benchmark that
scheme on batches consisting of 256 polynomials. We find, as expected, that the FRI-PCS commits elements
smaller than 31 bits no faster than it does 31-bit elements; we thus accordingly unify the results we present.
Table 4 describes our sumcheck prover’s performance. The performance profile of the sumcheck protocol’s
prover depends on the form of the virtual polynomial upon which that protocol is applied. We adopt
the standard course whereby we benchmark only multivariate polynomials defined as products of several
multilinears. Specifically, we present results corresponding to the products of 2, 3, and 4 multilinears. We
first benchmark our sumcheck prover in the tower field T7 ∼
= F2128 . We moreover benchmark the sumcheck
prover’s performance in the monomial-basis binary field F2128 ∼
= F2 [X]/(X 128 + X 127 + X 126 + X 121 + 1).
This field—and in particular, its irreducible polynomial—appears in Gueron, Langley and Lindell’s RFC
8452 [GLL19, § 3], and figures in that document’s POLYVAL polynomial authenticator. That particular
field makes available a certain highly optimized multiplication algorithm, which appears, for both the x86 64
and the ARM64 instruction sets, in Thomas Pornin’s BearSSL (these implementations use the PCLMULQDQ
and PMULL instructions, respectively). We note that each given sumcheck prover may, in practice, elect to
internally convert between the tower field T7 and the isomorphic monomial-basis field F2128 , for the sake
computational efficiency (and without thereby necessitating that the relevant verifier change in any way).

40

Finally, we benchmark the sumcheck prover over the BN254 scalar field, using Lasso’s implementation of
that prover.
In Tables 5 and 6, we benchmark both Plonky3 and this work on the Keccak-f task, which entails
proving the validity of 8,192 independent invocations of the Keccak-f [1600] permutation.
We ran all benchmarks on an Google Cloud c3-standard-22 cloud instance with a 4th-generation Intel
Xeon Scalable (“Sapphire Rapids 8488C”) processor, 22 virtual CPUs, and 88 GiB of RAM.
Commitment Scheme

Prob. Size

Coeff. Size

Pf. Size (MiB)

Commit (s)

Prove (s)

Verify (s)

220

1

0.031

0.1969

0.01296

0.02664

8

0.031

0.4760

0.03053

0.02647

32

0.031

1.716

0.03061

0.02655

1

0.125

3.148

0.2058

0.08664

8

0.125

6.157

0.4838

0.08610

32

0.125

24.82

0.4882

0.08639

1

0.500

50.40

3.303

0.2962

8

0.500

93.50

7.802

0.2943

32

0.500

297.3

7.854

0.2942

220

31

0.990

0.1262

0.01577

0.06496

Baby Bear

24

2

31

1.500

2.125

0.2491

0.08464

Poseidon

228

31

2.100

35.00

4.092

0.1086

Plonky3,

220

31

0.990

0.05909

0.01485

0.03657

Baby Bear

24

2

31

1.500

1.033

0.2381

0.04277

Keccak-256

228

31

2.100

17.53

3.962

0.05078

Our construction

220

1

0.229

0.002260

0.003343

0.006843

8

0.265

0.01904

0.004669

0.004186

32

0.369

0.05717

0.01661

0.004562

1

0.906

0.02436

0.08347

0.02002

8

0.942

0.2166

0.07961

0.01296

32

1.326

0.8334

0.3536

0.01514

1

3.546

0.3979

1.553

0.07140

8

4.058

3.345

1.855

0.03974

32

5.081

20.51

10.63

0.07019

Hyrax, BN254 G1

24

2

228

Plonky3

24

2

228

Table 2: Singlethreaded performance of commitment schemes in the ρ = 12 case.

41

Commitment Scheme

Prob. Size

Coeff. Size

Pf. Size (MiB)

Commit (s)

Prove (s)

Verify (s)

220

1

0.031

0.01591

0.001760

0.004896

8

0.031

0.03882

0.003191

0.004693

32

0.031

0.1404

0.003047

0.005291

1

0.125

0.2266

0.01774

0.01291

8

0.125

0.4451

0.04079

0.01173

32

0.125

1.824

0.04035

0.01228

1

0.500

3.531

0.2371

0.04023

8

0.500

6.550

0.6231

0.03643

32

0.500

21.42

0.6230

0.03895

220

31

0.990

0.01873

0.007697

0.06262

Baby Bear

24

2

31

1.500

0.2479

0.04761

0.08217

Poseidon

228

31

2.100

4.142

0.6652

0.1062

Plonky3

220

31

0.990

0.01133

0.007310

0.03462

Baby Bear

224

31

1.500

0.1657

0.04306

0.04102

Keccak-256

228

31

2.100

2.889

0.6542

0.04892

Our construction

220

1

0.229

0.0009150

0.001191

0.005620

8

0.265

0.003452

0.001584

0.003842

32

0.369

0.007446

0.002126

0.003653

1

0.906

0.003712

0.008356

0.01272

8

0.942

0.04027

0.01007

0.008109

32

1.326

0.1596

0.03096

0.009585

1

3.546

0.09003

0.2212

0.04136

8

4.058

0.8228

0.2604

0.02645

32

5.081

3.327

0.8555

0.02902

Hyrax, BN254 G1

24

2

228

Plonky3

224

28

2

Table 3: Multithreaded performance of commitment schemes in the ρ = 21 case.

42

Field

Num. Variables ℓ

Num. Multilinears

Prove (s)

Verify (s)

20

2

0.09755

0.00006163

3

0.1150

0.00007208

4

0.1397

0.0001127

2

1.428

0.00007190

3

1.670

0.00009728

4

2.033

0.0001194

2

21.69

0.0001174

3

26.07

0.0001058

4

34.09

0.0001188

2

0.05234

0.00001903

3

0.09794

0.00002047

4

0.1502

0.00002332

2

0.7780

0.00002181

3

1.420

0.00003230

4

2.247

0.00004054

2

12.111

0.00003134

3

22.36

0.00002818

4

35.63

0.00003636

2

0.01288

0.00003492

3

0.01911

0.00002925

4

0.02986

0.00003339

2

0.1295

0.00003063

3

0.2285

0.00004113

4

0.3566

0.00003888

2

1.877

0.00003508

3

3.409

0.00005481

4

5.538

0.00004534

BN254 Fr

24

28

T7 , tower basis

20

24

28

F2128 , monomial basis

20

24

28

Table 4: Multithreaded performance of the sumcheck prover on products of multilinear polynomials.

43

Protocol

Hash Used Internally

Proof Size (MiB)

Prove (s)

Verify (s)

Plonky3

Poseidon

4.010

120

0.639

Keccak-256

4.010

71.2

0.527

Grøstl

5.574

65.3

0.156

Our construction

Table 5: Singlethreaded performance on proving 8,192 Keccak-f s.

Protocol

Hash Used Internally

Proof Size (MiB)

Prove (s)

Verify (s)

Plonky3

Poseidon

4.010

17.4

0.644

Keccak-256

4.010

13.8

0.525

Grøstl

5.574

5.90

0.100

Our construction

Table 6: Multithreaded performance on proving 8,192 Keccak-f s.

References
[AHIV23]

Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam.
“Ligero: lightweight sublinear arguments without a trusted setup”. In: Designs, Codes and
Cryptography (2023). doi: 10.1007/s10623-023-01222-8.

[ark22]

arkworks contributors. arkworks zkSNARK ecosystem. 2022. url: https://arkworks.rs.

[BBHR18a]

Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Fast Reed–Solomon Interactive Oracle Proofs of Proximity”. In: International Colloquium on Automata, Languages,
and Programming. Ed. by Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and
Donald Sannella. Vol. 107. Leibniz International Proceedings in Informatics. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2018, 14:1–14:17. doi: 10.4230/
LIPIcs.ICALP.2018.14.

[BBHR18b]

Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and
post-quantum secure computational integrity. Cryptology ePrint Archive, Paper 2018/046.
2018. url: https://eprint.iacr.org/2018/046.

[BC14]

Daniel J. Bernstein and Tung Chou. “Faster Binary-Field Multiplication and Faster BinaryField MACs”. In: ed. by Antoine Joux and Amr Youssef. Cham: Springer International Publishing, 2014. isbn: 978-3-319-13051-4. doi: 10.1007/978-3-319-13051-4_6.

[BCG20]

Jonathan Bootle, Alessandro Chiesa, and Jens Groth. “Linear-Time Arguments with Sublinear
Verification from Tensor Codes”. In: Theory of Cryptography. Ed. by Rafael Pass and Krzysztof
Pietrzak. Cham: Springer International Publishing, 2020, pp. 19–46. isbn: 978-3-030-64378-2.
doi: 10.1007/978-3-030-64378-2_2.

[BCKL22]

Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. “Scalable and Transparent
Proofs over All Large Fields, via Elliptic Curves”. In: Theory of Cryptography. Ed. by Eike
Kiltz and Vinod Vaikuntanathan. Cham: Springer Nature Switzerland, 2022, pp. 467–496.
isbn: 978-3-031-22318-1. doi: 10.1007/978-3-031-22318-1_17.

[BCKL23]

Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. “Elliptic Curve Fast Fourier
Transform (ECFFT) Part I: Low-degree Extension in Time O(n log n) over all Finite Fields”.
In: ACM-SIAM Symposium on Discrete Algorithms. Society for Industrial and Applied Mathematics, Nov. 2023, pp. 700–737. doi: doi:10.1137/1.9781611977554.ch30.
44

[BCS16]

Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In:
International Conference on Theory of Cryptography. Vol. 9986. Berlin, Heidelberg: SpringerVerlag, 2016, pp. 31–60. isbn: 978-3-662-53644-5. doi: 10.1007/978-3-662-53644-5_2.

[BCS97]

Wieb Bosma, John Cannon, and Allan Steel. “Lattices of Compatibly Embedded Finite
Fields”. In: Journal of Symbolic Computation 24.3 (1997), pp. 351–369. doi: https://doi.
org/10.1006/jsco.1997.0138. url: https://www.sciencedirect.com/science/article/
pii/S0747717197901383.

[BDPV11]

Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. The Keccak reference.
2011. url: https://keccak.team/files/Keccak-reference-3.0.pdf.

[BDSW23]

Carsten Baum, Samuel Dittmer, Peter Scholl, and Xiao Wang. “SoK: Vector OLE-based zeroknowledge protocols”. In: Designs, Codes and Cryptography 91.11 (2023), pp. 3527–3561. doi:
10.1007/s10623-023-01292-8.

[Ben+23]

Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. “Proximity
Gaps for Reed–Solomon Codes”. In: Journal of the ACM 70.5 (Oct. 2023). doi: 10.1145/
3614423.

[BFS20]

Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: Advances in Cryptology – EUROCRYPT 2020. Ed. by Anne Canteaut and Yuval
Ishai. Cham: Springer International Publishing, 2020, pp. 677–706.

[BGKS19]

Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling
Outside the Box Improves Soundness. Cryptology ePrint Archive, Paper 2019/336. 2019. url:
https://eprint.iacr.org/2019/336.

[BGR23]

Jeremy Bruestle, Paul Gafni, and RISC Zero Team. RISC Zero zkVM: Scalable, Transparent
Arguments of RISC-V Integrity. 2023. url: https://dev.risczero.com/proof-system-indetail.pdf (visited on 11/12/2023).

[Bla+93]

Ian F. Blake, XuHong Gao, Ronald C. Mullin, Scott A. Vanstone, and Tomik Yaghoobian.
Applications of Finite Fields. Ed. by Alfred J. Menezes. The Springer International Series in
Engineering and Computer Science. Springer Science+Business Media, 1993.

[Blu+91]

Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. “Checking the
Correctness of Memories”. In: Proceedings of the 32nd Annual Symposium on Foundations of
Computer Science. IEEE Computer Society, 1991, pp. 90–99. isbn: 0818624450. doi: 10.1109/
SFCS.1991.185352.

[CBBZ23]

Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. “HyperPlonk: Plonk with LinearTime Prover and High-Degree Custom Gates”. In: Advances in Cryptology – EUROCRYPT
2023. Ed. by Carmit Hazay and Martijn Stam. Vol. 14005. Lecture Notes in Computer Science.
Cham: Springer Nature Switzerland, 2023.

[CCXY18]

Ignacio Cascudo, Ronald Cramer, Chaoping Xing, and Chen Yuan. “Amortized Complexity
of Information-Theoretically Secure MPC Revisited”. In: Advances in Cryptology – CRYPTO
2018. Ed. by Hovav Shacham and Alexandra Boldyreva. Cham: Springer International Publishing, 2018, pp. 395–426. isbn: 978-3-319-96878-0. doi: 10.1007/978-3-319-96878-0_14.

[CG22]

Ignacio Cascudo and Emanuele Giunta. “On Interactive Oracle Proofs for Boolean R1CS
Statements”. In: Financial Cryptography and Data Security. Ed. by Ittay Eyal and Juan Garay.
Cham: Springer International Publishing, 2022, pp. 230–247. isbn: 978-3-031-18283-9. doi:
10.1007/978-3-031-18283-9_11.

[Che+18]

Ming-Shing Chen, Chen-Mou Cheng, Po-Chun Kuo, Wen-Ding Li, and Bo-Yin Yang. Faster
Multiplication for Long Binary Polynomials. 2018. url: https : / / arxiv . org / abs / 1708 .
09746.

45

[Chi+20]

Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas
Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Advances
in Cryptology – EUROCRYPT 2020. Ed. by Anne Canteaut and Yuval Ishai. Lecture Notes in
Computer Science. Full version. Cham: Springer International Publishing, 2020, pp. 738–768.
isbn: 978-3-030-45721-1. doi: 10.1007/978-3-030-45721-1_26.

[CLRS22]

Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction
to Algorithms. Fourth Edition. The MIT Press, 2022.

[Coh92]

Stephen D. Cohen. “The Explicit Construction of Irreducible Polynomials Over Finite Fields”.
In: Designs, Codes and Cryptography 2.2 (1992), pp. 169–174.

[DP24]

Benjamin E. Diamond and Jim Posen. “Proximity Testing with Logarithmic Randomness”. In:
IACR Communications in Cryptology 1.1 (2024). issn: 3006-5496. doi: 10.62056/aksdkp10.

[FP97]

John L. Fan and Christof Paar. “On efficient inversion in tower fields of characteristic two”.
In: Proceedings of IEEE International Symposium on Information Theory. 1997.

[Gau+11]

Praveen Gauravaram, Lars R. Knudsen, Krystian Matusiewicz, Florian Mendel, Christian
Rechberger, Martin Schläffer, and Søren S. Thomsen. Grøstl – a SHA-3 candidate. 2011. url:
https://www.groestl.info/Groestl.pdf (visited on 11/12/2023).

[GBHL22]

Jack Grigg, Sean Bowe, Daira Hopwood, and Ying Tong Lai. The halo2 Book. 2022. url:
https://zcash.github.io/halo2.

[GKR15]

Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating Computation:
Interactive Proofs for Muggles”. In: Journal of the ACM 62.4 (Sept. 2015). issn: 0004-5411.
doi: 10.1145/2699436.

[GLL19]

Shay Gueron, Adam Langley, and Yehuda Lindell. AES-GCM-SIV: Nonce Misuse-Resistant
Authenticated Encryption. RFC 8452. Apr. 2019.

[Gol+23]

Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S. Wahby. “Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS”. In: Advances in Cryptology –
CRYPTO 2023. Ed. by Helena Handschuh and Anna Lysyanskaya. Cham: Springer Nature
Switzerland, 2023, pp. 193–226. doi: 10.1007/978-3-031-38545-2_7.

[Gra]

Markus Grassl. Bounds on the minimum distance of linear codes and quantum codes. http:
//www.codetables.de.

[Gra+19]

Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus
Schofnegger. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. Cryptology ePrint Archive, Paper 2019/458. 2019. url: https://eprint.iacr.org/2019/458.

[Gur06]

Venkatesan Guruswami. Algorithmic Results in List Decoding. Vol. 2. Foundations and Trends
in Theoretical Computer Science 2. now publishers, 2006. doi: 10.1561/0400000007.

[GWC19]

Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over
Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint
Archive, Paper 2019/953. 2019. url: https://eprint.iacr.org/2019/953.

[Hab22]

Ulrich Haböck. A summary on the FRI low degree test. Cryptology ePrint Archive, Paper
2022/1216. 2022. url: https://eprint.iacr.org/2022/1216.

[HR22]

Justin Holmgren and Ron D. Rothblum. “Faster Sounder Succinct Arguments and IOPs”. In:
Advances in Cryptology – CRYPTO 2022. Ed. by Yevgeniy Dodis and Thomas Shrimpton.
Cham: Springer Nature Switzerland, 2022, pp. 474–503. isbn: 978-3-031-15802-5. doi: 10 .
1007/978-3-031-15802-5_17.

[Kil92]

Joe Kilian. “A Note on Efficient Zero-Knowledge Proofs and Arguments (Extended Abstract)”.
In: Proceedings of the Twenty-Fourth Annual ACM Symposium on Theory of Computing. New
York, NY, USA: Association for Computing Machinery, 1992, pp. 723–732.

[KZG10]

Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: Advances in Cryptology – ASIACRYPT 2010. Ed. by
Masayuki Abe. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, pp. 177–194. isbn: 9783-642-17373-8. doi: 10.1007/978-3-642-17373-8.
46

[LCH14]

Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han. “Novel Polynomial Basis and Its Application to Reed–Solomon Erasure Codes”. In: IEEE 55th Annual Symposium on Foundations
of Computer Science. 2014, pp. 316–325. doi: 10.1109/FOCS.2014.41.

[LFKN92]

Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. “Algebraic Methods for
Interactive Proof Systems”. In: Journal of the ACM 39.4 (Oct. 1992), pp. 859–868. doi: 10.
1145/146585.146605. url: https://doi.org/10.1145/146585.146605.

[MBKM19]

Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. “Sonic: Zero-Knowledge
SNARKs from Linear-Size Universal and Updatable Structured Reference Strings”. In: Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security.
2019, pp. 2111–2128. isbn: 9781450367479. doi: 10.1145/3319535.3339817.

[Pol22]

Polygon Zero Team. Plonky2: Fast Recursive Arguments with PLONK and FRI. GitHub. 2022.
url: https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/plonky2.pdf.

[RR22]

Noga Ron-Zewi and Ron D. Rothblum. “Proving as Fast as Computing: Succinct Arguments
with Constant Prover Overhead”. In: ACM SIGACT Symposium on Theory of Computing.
Association for Computing Machinery, 2022, pp. 1353–1363. isbn: 9781450392648. doi: 10.
1145/3519935.3519956.

[Set20]

Srinath Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”.
In: Advances in Cryptology – CRYPTO 2020. Ed. by Daniele Micciancio and Thomas Ristenpart. Cham: Springer International Publishing, 2020, pp. 704–737. isbn: 978-3-030-56877-1.
doi: 10.1007/978-3-030-56877-1_25.

[SL20]

Srinath Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Paper 2020/1275. 2020. url: https://eprint.iacr.org/2020/1275.

[Sta21]

StarkWare. ethSTARK Documentation. Cryptology ePrint Archive, Paper 2021/582. 2021.
url: https://eprint.iacr.org/2021/582.

[STW23]

Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct
arguments. Cryptology ePrint Archive, Paper 2023/552. 2023. url: https://eprint.iacr.
org/2023/552.

[STW24]

Srinath Setty, Justin Thaler, and Riad Wahby. “Unlocking the Lookup Singularity with Lasso”.
In: Advances in Cryptology – EUROCRYPT 2024. Ed. by Marc Joye and Gregor Leander.
Cham: Springer Nature Switzerland, 2024, pp. 180–209. isbn: 978-3-031-58751-1. doi: 10 .
1007/978-3-031-58751-1_7.

[Tha22]

Justin Thaler. Proofs, Arguments and Zero-Knowledge. Vol. 4. Foundations and Trends in
Privacy and Security 2–4. now publishers, 2022.

[Val08]

Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply
Time/Space Efficiency”. In: Proceedings of the 5th Conference on Theory of Cryptography.
New York, USA: Springer-Verlag, 2008, pp. 1–18. isbn: 354078523X.

[Wah+18]

Riad S. Wahby, Ioanna Tzialla, abhi shelat abhi, Justin Thaler, and Michael Walfish. “DoublyEfficient zkSNARKs Without Trusted Setup”. In: IEEE Symposium on Security and Privacy.
2018, pp. 926–943. doi: 10.1109/SP.2018.00060.

[Wie88]

Doug Wiedemann. “An Iterated Quadratic Extension of GF (2)”. In: The Fibonacci Quarterly
26.4 (1988), pp. 290–295.

[WYKW21]

Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. “Wolverine: Fast, Scalable, and
Communication-Efficient Zero-Knowledge Proofs for Boolean and Arithmetic Circuits”. In:
IEEE Symposium on Security and Privacy. 2021, pp. 1074–1091. doi: 10 . 1109 / SP40001 .
2021.00056.

47

A

Deferred Proofs

Proof of Theorem 3.12. We fix an adversary
A who outputs a commitment
c and pairs (t0 , u0 ) and (t1 , u1 ).


Assuming that Π.Open params, c; t0 , u0 and Π.Open params, c; t1 , u1 both hold, we argue as follows. We
write M 0 and M 1 for the subsets of {0, . . . , n − 1} respectively missing from the hints u0 and u1 . We
moreover write:
 m −1
 m −1
m0 −1 
m0 −1 
0
0
∪ M 1.
∪ M 0 ∪ ∆m0 u1i i=0 , Enc(t1i ) i=0
X := ∆m0 u0i i=0 , Enc(t0i ) i=0
On the
our hypothesis immediately
implies that |X| < d. On the other hand, we claim that

 one hand,


1 m0 −1
m0
0 m0 −1
⊂ X. Indeed, proceeding by contraposition, we fix an index j ̸∈ X.
∆
Enc(ti ) i=0 , Enc(ti ) i=0
m0 −1
Since j ̸∈ M0 ∪ M1 , we see that the hints u0 and u1 respectively Merkle-open the columns u0i,j i=0 and
m0 −1
u1i,j i=0 against c, so that—barring an oracle collision on the part of A—these columns are necessarily
 
 
m0 −1 
m0 −1 
m0 −1
m0 −1
identical. On the other hand, since j ̸∈ ∆m0 u0i i=0 , Enc(t0i ) i=0
∪ ∆m0 u1i i=0 , Enc(t1i ) i=0 ,
m0 −1
m0 −1
m0 −1
m0 −1
we see that Enc(t0i )j i=0 = u0i,j i=0 and Enc(t1i )j i=0 = u1i,j i=0 . Combining these facts, we see

m0 −1
m0 −1
m0 −1
m0 −1 
that Enc(t0i )j i=0 = Enc(t1i )j i=0 , so that j ̸∈ ∆m0 Enc(t0i ) i=0 , Enc(t1i ) i=0 , as desired. We
m0 −1
m0 −1
conclude that Enc(t0i )j i=0 = Enc(t1i )j i=0 . Because Enc is injective, we finally conclude that t0 = t1 as
packed matrices; because the natural embedding is injective (see also Theorem 3.9 above), we finally deduce
the equality of t0 and t1 as unpacked matrices, and hence as polynomials in Tι [X0 , . . . , Xℓ−1 ].
Proof of Theorem 3.13. We define an emulator E.
(r0 , . . . , rℓ−1 ), E operates as follows.

Given access to A, and on inputs params, c and

1. Having observed and collected A’s queries up until the point of its outputting c, E initializes the empty
m0 −1
matrix (ui )i=0
. E defines the following algorithm, which is essentially a slight simplification of an
algorithm, called Valiant’s extractor, given in Ben-Sasson, Chiesa and Spooner [BCS16, § A.1].
1: procedure TreeBuilder(h,
i, j)

2:

3:
4:
5:

?

m −1

0
if i = 0 and h = H (xi )i=0

overwrite the value of the j

arises as some oracle output then

th

m −1

0
column (ui,j )i=0

m0 −1
:= (xi )i=0
.

?

else if i > 0 and h = H(h0 ∥ h1 ) arises as some oracle output then
recursively kick off TreeBuilder(h0 , i − 1, 2 · j) and TreeBuilder(h1 , i − 1, 2 · j + 1).

E executes TreeBuilder(c, log n, 0). E writes M ⊂ {0, . . . , n − 1} for the set of never-assigned indices.
2. E internally runs A on the further input (r0 , . . . , rℓ−1 ) in a straight-line manner, until A outputs s and
π. If Π.Verify(params, c, s, (r0 , . . . , rℓ−1 ), π) = 0, then E outputs (s, π; ⊥, ⊥) and terminates.
3. E defines:
1: procedure ExtractProof()
2:
while true do
3:
freshly sample (r0 , . . . , rℓ−1 ) ← Q(params).
4:
run A on (r0 , . . . , rℓ−1 ), with fresh verifier randomness, until it outputs (s, π).
5:
rewind A to its initial point (i.e., immediately after outputting c).
6:
if Π.Verify(params, c, s, (r0 , . . . , rℓ−1 ), π) then return t′ and (r0 , . . . , rℓ−1 ).
E writes (r0,0 , . . . , r0,ℓ−1 ) for the randomness it used in A’s initial proof above and t′0 for the message
sent by A during the course of its initial proof. By running the routine ExtractProof() above m0 −1
m0 −1
m0 −1
further times, E extends these quantities to matrices (t′i )i=0
and (ri,0 , . . . , ri,ℓ−1 )i=0
.
N
m0 −1
ℓ−1
4. E checks if the m0 × m0 matrix
is invertible. If it’s not, E outputs
j=ℓ1 (1 − ri,j , ri,j )
i=0

(s, π; ⊥, u).

48

5. Otherwise, using the constant Tτ -vector space structure on Aι,κ,τ , E performs the matrix operation:








t0
..
.







 := 



tm0 −1

Nℓ−1

j=ℓ1 (1 − r0,j , r0,j )
..
.

Nℓ−1

j=ℓ1 (1 − rm0 −1,j , rm0 −1,j )

−1 







·


t′0
..
.
t′m0 −1




.


m −1

0
do not reside entirely in the subring Aι,κ,ι ⊂ Aι,κ,τ , then E outputs (s, π; ⊥, u).
If the entries of (ti )i=0
m0 −1
Otherwise, E recovers the unpacked matrix (ti )i=0
by reversing the Tι -isomorphism of Theorem
3.9, sets as t(X0 , · · · , Xℓ−1 ) ∈ Tι [X0 , · · · , Xℓ−1 ] the polynomial whose coefficients (in the multilinear
m0 −1
Lagrange basis) are given by the concatenation of (ti )i=0
’s rows, and outputs (s, π; t, u).

In the algorithm TreeBuilder, we understand the conditions 2 and 4 as demanding that the relevant
preimages be well-formed. That is, in case h does arise as the output of a prior query, whose input, however,
is malformed (in that it doesn’t match the format demanded), we understand the relevant condition as failing
to be fulfilled. If h arises as the output of multiple, distinct, well-formed preimages, then we stipulate that
E select arbitrarily among these preimages (this event can only occur if A finds an oracle collision).
We now argue that E runs in expected polynomial time in λ. We write ε for the probability that A passes,
conditioned on its state as of the point at which it first outputs c (this probability is taken over the coins
of both Q and V, and over the further coins of A). We note that, for each fixed c, E proceeds beyond step
2 above with probability exactly ε. Moreover, each execution of ExtractProof terminates in expected
time exactly 1ε , since that algorithm’s line 6 passes with probability exactly ε per iteration of that algorithm.
Finally, TreeBuilder is straight-line and polynomial time. We conclude that E’s total expected runtime is
at most that of TreeBuilder plus 1 + ε · m0ε−1 = m times the time it takes to run Construction 3.11 once;
this total time is thus polynomial in λ (and independent of c and ε).
We now analyze the distribution returned by E. We note that the outputs (c, s, π) upon which D
Π,ℓ
runs are identically distributed in the distributions RealΠ,ℓ
Q,A,E,D (λ) and IdealQ,A,E,D (λ). It thus suffices to
show that it holds in at most a negligible proportion of executions of A, Q and E that, simultaneously,
Π.Verify(params, c, s, (r0 , . . . , rℓ−1 ), π) = 1 and either Π.Open(params, t; c, u) = 0 or t(r0 , . . . , rℓ−1 ) ̸= s. We
write Q(λ) for a polynomial upper bound on the number of random oracle queries A makes. We recall from
2
+1
[BCS16, § A.1] that it holds with probability at most Q(λ)
, which is negligible, that A outputs—during
2λ
any particular among its executions—either a valid Merkle path on a missing column j ∈ M or, for some
m0 −1
j ̸∈ M , a valid Merkle opening (ui,j )i=0
inconsistent with the matrix extracted by E in step 1 above.
n
b
output by Π.Setup (i.e., see Subsection
We recall the extension code C ⊂ Aι,κ,τ of the code C ⊂ Tι+κ
3.1). The following lemma shows that we may, moreover, safely restrict our attention to the setting in
0 −1
b Though the matrix (ui )m0 −1
which the extracted matrix (ui )m
features correlated agreement with C.
i=0
i=0
has, by definition, entries in the synthetic subring Aι,κ,ι ⊂ Aι,κ,τ , for the purposes of the below lemma, we
b at M .
temporarily view it as a matrix with entries in Aι,κ,τ . We write C for the puncturing of C


m0
m0 −1
Lemma A.1. If E’s matrix satisfies dm0 (ui )i=0
,C
≥ d3 −|M |, then A passes with negligible probability.
Proof. We first argue that we may freely assume that |M | < d3 . Indeed, if |M | ≥ d3 , then J ∩ M = ∅ holds

d γ
with probability at most 1 − 3·n
, which is negligible, since d = Ω(n) and γ = Θ(λ). On the other hand,
A can pass in case J ∩ M ̸= ∅ only by submitting valid a Merkle

 opening against a missing column.
:= d−1
We thus assume that |M | < d3 , and
moreover
write
e
at
j
k j
k  3  − |M |. Since the distance, nsay d, ofj C isko
d−|M |−1
d−1
d−1
d−1
least d − |M |, which itself satisfies 3 ≥
≥ 3 − |M | = e, we see that e ∈ 0, . . . , 3
.
 3

N
m0
m0 −1
ℓ−1
On the other hand, by our hypothesis, dm0 (ui )i=0
,C
> e. We abbreviate u′ := i=ℓ1 (1 − ri , ri ) ·
m −1

0
(ui )i=0
. Applying the contraposition of Theorem 3.10 to the code C, we conclude that, provided that the
in
second part (rℓ1 , . . . , rℓ−1 ) ∈ Tτℓ0 of the verifier’s random point resides outside a set of mass at most 2·ℓ0 · e+1
τ| 

|Td−1
ℓ0
′
′
′
Tτ , we have d u , C > e. In particular, for each such (rℓ1 , . . . , rℓ−1 ), |∆(u , Enc(t )) ∪ M | > e+|M | = 3
in fact holds, since Enc(t′ ) is a codeword. We conclude that J ∩ (∆(u′ , Enc(t′ )) ∪ M ) = ∅ holds with

49


d γ
probability at most 1 − 3·n
. On the other hand, if J ∩ (∆(u′ , Enc(t′ )) ∪ M ) ̸= ∅, then we claim that
V accepts with negligible probability. Indeed, A can pass on an index j ∈ M only by Merkle-opening a
new column and on an index j ∈ ∆(u′ , Enc(t′ )) \ M only by Merkle-opening a column inconsistent with E’s
m0 −1
.
extracted column (ui,j )i=0

2
+1
d γ
Putting the pieces together, we see that A’s chance of passing is at most Q(λ)
+ 2 · ℓ0 · |Tdτ | + 1 − 3·n
2λ
d
ω(log λ)
holds by construction, and d
(here, we crudely upper-bound 2 · ℓ0 · e+1
|Tτ | ≤ 2 · ℓ0 · |Tτ | ). As |Tτ | ≥ 2

d
d γ
and ℓ0 are polynomial in λ, 2 · ℓ0 · |Tτ | is negligible. On the other hand, we again have that 1 − 3·n
is
negligible. This completes the proof of the lemma.


m0
m0 −1
Applying Lemma A.1, we assume henceforth that dm0 (ui )i=0
,C
< d3 − |M |. We conclude immedi

m0 −1
m0 −1
m0 −1
∪ M < d3 .
, (Enc(ti ))i=0
for which ∆m0 (ui )i=0
ately that there exists an interleaved message (ti )i=0


m0 −1
m0 −1
, (Enc(ti ))i=0
< d3 too holds. The following lemma shows that we
We note that, a fortiori, dm0 (ui )i=0
Nℓ−1
m0 −1
may further restrict our attention to the case in which A correctly outputs t′ = i=ℓ1 (1 − ri , ri ) · (ti )i=0
during its initial proof.
Nℓ−1
m0 −1
Lemma A.2. If its message t′ ̸= i=ℓ1 (1 − ri , ri ) · (ti )i=0
, then A passes with negligible probability.


Nℓ−1
m0 −1
Proof. We write e := d−1
, and abbreviate u′ :=
i=ℓ1 (1 − ri , ri ) · (ui )i=0 ; we moreover write
3
N
ℓ−1
m0 −1
v ′ :=
ri , ri ) · (Enc(ti ))i=0
. By the argument just given, we may freely assume that
i=ℓ1 (1 − 

m0 −1 b m0
m0
d
(ui )
,C
≤ e holds; in particular, d(u′ , v ′ ) ≤ e. On the other hand, our hypothesis implies
i=0

that Enc(t′ ) ̸= v ′ . By the reverse triangle inequality, we thus have:
d(u′ , Enc(t′ )) ≥ |d(Enc(t′ ), v ′ ) − d(u′ , v ′ )| ≥ d − e.
γ

2·d γ
≤ 1 − 3·n
, which is
We see that J ∩ ∆(u′ , Enc(t′ )) = ∅ holds with probability at most 1 − d−e
n
negligible. On the other hand, if V queries any position j ∈ ∆(u′ , Enc(t′ )), then either j ∈ M or j ∈
∆(u′ , Enc(t′ )) \ M ; in these cases, A can pass only by exhibiting an oracle collision (on a missing or on an
existing column, respectively). This again completes the proof, in light of the guarantees d = Ω(n) and
γ = Θ(λ).
The following lemma is specific to our setting, and doesn’t appear in [DP24]. We
 continue to assume

m0 −1
m −1 b m0
m0
that (ui )
has entries in the synthetic subring Aι,κ,ι ⊂ Aι,κ,τ , as well as that d
(ui ) 0 , C
< d.
i=0

Lemma A.3.

i=0

3

m0 −1
The matrix of messages (ti )i=0
also has entries in the subring Aι,κ,ι ⊂ Aι,κ,τ .

Proof. We assume for contradiction that the row ti∗ , say, where i∗ ∈ {0, . . . , m0 − 1}, satisfies ti∗ ,j ∗ ̸∈ Aι,κ,ι
1
for some component j ∗ ∈ {0, . . . , m
2κ − 1}. We recall the Tι+κ -basis (βv )v∈Bτ −ι of Aι,κ,τ introduced above.
Expressing each component of ti∗ in coordinates with respect to this basis, we express ti∗ as a collection of
m1/2κ
2τ −ι vectors ti∗ ,v ∈ Tι+κ , for v ∈ Bτ −ι . Our hypothesis on ti∗ entails precisely that at least one nonzerom1/2κ
indexed slice—indexed v ∗ ∈ Bτ −ι \ {(0, . . . , 0)}, say—is not identically zero (i.e., as Tι+κ -element).
b generator matrix has entries in Tι+κ , we see that the encoding Enc(ti∗ ) ∈
Again exploiting the fact that C’s
n
Aι,κ,τ is precisely given, slice-wise, by the respective slice-encodings Enc(ti∗ ,v ), for v ∈ Bτ −ι . Since ti∗ ,v∗ is
n
not identically zero, we conclude that Enc(ti∗ ,v∗ ) ∈ Tι+κ
is necessarily nonzero at at least d positions.
∗th
Since ui∗ is defined over Aι,κ,ι , its v
slice ui∗,v∗ is identically zero. We conclude that d(ui∗ , Enc(ti∗ )) ≥
m −1

m −1

0
0
, (Enc(ti ))i=0
d; this inequality contradicts our assumption dm0 (ui )i=0

< d3 , itself justified above.



m0 −1 b m0
Lemma A.3 shows that, under the hypothesis dm0 (ui )i=0
,C
< d3 —and assuming, as usual, that


m0 −1
m0 −1
(ui )i=0
is defined over Aι,κ,ι ⊂ Aι,κ,τ —we actually obtain the stronger conclusion dm0 (ui )i=0
, C m0 <
m1/2κ
d
n
3 . Indeed, for each i ∈ {0, . . . , m0 − 1}, since ti ∈ Aι,κ,ι (by Lemma A.3), we conclude that Enc(ti ) ∈ Aι,κ,ι .

50

We thus restrict our attention
and there exists a message
 to the case in which A’s initial proof π passes
Nℓ−1
m0 −1
m0 −1
m0 −1
d
m0
′
∆
(ui )i=0 , (Enc(ti ))i=0
∪ M < 3 and t = i=ℓ1 (1 − ri , ri ) · (ti )i=0
hold.
We denote:

γ
Q(λ)2 + 1
2·d
ℓ0
δ :=
+
1
−
+
.
λ
2
3·n
|Tτ |
√
Since δ is negligible in λ, √δ also is. In this light, we may simply ignore each execution for which A’s
probability of success ε ≤ δ, since in
√ that case E proceeds into step 3 in the first place with negligible
probability. We thus assume that ε > δ in what follows. In the following technical lemma, we write V for
the event in which A submits an accepting proof, and E for a further, arbitrary event.
√
√
Lemma A.4. Assuming as above that Pr[V ] > δ, if Pr[V ∧ E] ≤ δ moreover holds, then Pr[E | V ] ≤ δ.
m0 −1
(ti )i=0
for which both

Proof. Assuming the hypotheses of the lemma, we see that
Pr[E | V ] =

√
Pr[V ∧ E]
δ
< √ = δ,
Pr[V ]
δ

as required.
Lemma A.5. The probability that t′i ̸=

m0 −1
for any i ∈ {1, . . . , m0 −1} is negligible.
j=ℓ1 (1−ri,j , ri,j )·(ti )i=0

Nℓ−1

Proof. For each i∗ ∈ {1, . . . , m0 − 1}, we write Ei∗ for the event in which A’s i∗th message t′i∗ ̸=
m0 −1
ri∗ ,j , ri∗ ,j ) · (ti )i=0
. By the argument of Lemma A.2, Pr[V

2
+1
| Ei∗ ] is at most Q(λ)
+
2λ

Nℓ−1

j=ℓ1 (1 −

2·d γ
1 − 3·n ≤ δ. We

thus see that Pr[V
√ ∧ Ei∗ ] = Pr[V | Ei∗ ] · Pr[Ei∗ ] ≤ δ, so that the hypothesis of Lemma A.4 is fulfilled, and
Pr[Ei∗ | V ] ≤ δ holds. The probability that any among the events E1 , . . . , Em0 −1 holds is thus at most

√ m0 −1
√
1− 1 − δ
≤ (m0 − 1) · δ, which is negligible (here, we use a standard binomial approximation).
Lemma A.6. The probability that the rows

m0 −1

N

ℓ−1
j=ℓ1 (1 − ri,j , ri,j )

are linearly dependent is negligible.

i=0

Proof.
We first argue that for A ⊂ oTτm0 an arbitrary proper linear subspace, and S :=
n
Nℓ−1
ℓ0
(rℓ1 , . . . , rℓ−1 ) ∈ Tτℓ0
i=ℓ1 (1 − ri , ri ) ∈ A its preimage under the tensor map, we have µ(S) ≤ |Tτ | . It
suffices to prove the result only in case A is a hyperplane. We write a = (a0 , . . . , am0 −1 ) ∈ Tτm0 for a vector
of coefficients, not all zero, for which A = {u ∈ Tτm0 | u · a = 0} holds. By construction, (rℓ1 , . . . , rℓ−1 ) ∈ S if
Nℓ−1
and only if i=ℓ1 (1 − ri , ri ) · a = 0. We note that S ⊂ Tτℓ0 is nothing other than the vanishing locus of that
combination of the ℓ0 -variate multilinear Lagrange polynomials given by the coefficient vector a. Because
a is not identically zero and these polynomials are linearly independent, we conclude that the combination
is itself nonzero. Applying Schwartz–Zippel, we see that the vanishing locus S ⊂ Tτℓ0 is of mass at most
µ(S) ≤ |Tℓ0τ | , as desired.
Nℓ−1
We note that j=ℓ1 (1 − r0,j , r0,j ) is not the zero vector, since its components necessarily sum to 1. For
N
i∗ −1
ℓ−1
each i∗ ∈ {1, . . . , m0 − 1}, we set as Ai∗ ⊂ Tτm0 the span of
, and write Ei∗ for the
j=ℓ1 (1 − ri,j , ri,j )
i=0
Nℓ−1
event in which j=ℓ1 (1 − ri∗ ,j , ri∗ ,j ) ∈ Ai∗ . The above argument implies exactly that Pr[Ei∗ ] ≤ |Tℓ0τ | ≤ δ; we
conclude in particular that Pr[V ∧ Ei∗ ] = Pr[V | Ei∗ ] · Pr[Ei∗ ] ≤ δ, and the hypothesis of Lemma A.4 is again
fulfilled. Applying Lemma A.4 repeatedly, we conclude again that the probability that any of the events Ei∗

√ m0 −1
√
holds, for i∗ ∈ {1, . . . , m0 − 1}, is at most 1 − 1 − δ
≤ (m0 − 1) · δ, which is negligible.
0 −1
We finally argue that the values t and u = (ui )m
extracted by E satisfy Π.Open(params, c; t, u) and
i=0
m0 −1
t(r0 , .. . , rℓ−1 ) = s. Indeed, under
the
condition
guaranteed
by Lemma A.1, a matrix (ti )i=0
for which


m −1

m −1

0
0
∆m0 (ui )i=0
, (Enc(ti ))i=0

∪ M < d3 exists. Under the conditions guaranteed by Lemmas A.5 and

0 −1
A.6, E extracts precisely this matrix (ti )m
in steps 3 and 5. By Lemma A.3, this matrix is a postei=0
riori defined over Aι,κ,ι , and thus—up to reversing Theorem 3.9’s Tι -isomorphism—defines a polynomial
t(X0 , . . . , Xℓ−1 ) ∈ Tι [X0 , . . . , Xℓ−1 ]⪯1 , as required. Finally, Lemma A.2 guarantees that A’s first message

51

Nℓ−1
m0 −1
; on the other hand, Π.Verify(params, c, s, (r0 , . . . , rℓ−1 ), π) implies that
satisfies t′ = i=ℓ1 (1−ri , ri )·(ti )i=0
N
Nℓ−1
ℓ
−1
m0 −1 Nℓ1 −1
1
′
s = t · i=0 (1−ri , ri ). We conclude that s = i=ℓ1 (1−ri , ri )·(ti )i=0
· i=0 (1−ri , ri ) = t(r0 , . . . , rℓ−1 ),
as required. This completes the proof of the theorem.
Proof of Theorem 3.14. We recall first of all the guarantee ℓ = O(log λ), which holds by assumption throughout Construction 3.11; we moreover assume that, for ι ≥ 0 arbitrary, each Tι -multiplication imposes a cost
polynomial in the bit-length2ι .



We set γ := λ and τ := log(log2 (λ)) , as well as as well as ℓ1 := 21 · (ℓ + log γ) and ℓ0 := ℓ − ℓ1 , and
finally write m0 := 2ℓ0 and m1 := 2ℓ1 . Since the statement is asymptotic and ι is constant, √
we assume
p freely
that τ ≥ ι. We note that m0 and m1 differ by at most a factor of 2 from, respectively, √1γ · 2ℓ and γ · 2ℓ .
ι+κ

1
We fix the rate ρ := 12 , and moreover set κ ≥ 0 minimally so that |Tι+κ | = 22
≥ ρ1 · m
2κ holds (equivalently,
ι+κ
so that 2
+ κ ≥ − log ρ + ℓ1 holds). We note that this minimal κ necessarily satisfies κ ≤ ℓ1 . Indeed,
the choice κ = ℓ1 itself certainly satisfies 2ι+ℓ1 + ℓ1 ≥ 1 + ℓ1 = − log ρ + ℓ1 , as required. We conclude that
n
1
:= ρ1 · k, and set as C ⊂ Tι+κ
the Reed–Solomon code RSTι+κ [n, k].
2κ ≤ m1 ; we finally write k := m
2κ and n
We note that, by our choice of κ, this code exists. On the other hand, by the minimality of κ, we moreover
n
have the upper-bound 2ι+κ ≤ 2 · (− log(ρ) + ℓ1 − κ) = O(ℓ). We note that the values γ, τ , κ, and C ⊂ Tι+κ
chosen in this way fulfill the requirements of Π.Setup.
We assume that each bit received imposes constant cost;
that
total
q the protocol’s
 we see immediately
p
√
2
2ℓ
τ
ι+κ
ℓ
ℓ
e
· γ = O( 2 ).
communication-attendant cost is 2 · m1 + 2
· m0 · γ = O log (λ) · γ · 2 + ℓ ·

γ

2
τ
Again by our choice of τ , we see that each Tτ -operation costs polynomially
√ in 2 = O(log λ), and so costs
e
e 0 + m1 ) = O
e λ · 2ℓ . We analyze the total cost
O(1).
We see that the total cost of all Tτ -operations is O(m

of all Tι operations in the following way. Since 2κ ≤ 2ι+κ = O(ℓ), and since the cost of 2τ −ι Tι -operations is
certainly at most that of one Tτ -operation, we see that the total cost imposed by 2κ· 2τ −ι Tι-operations
√ is at

p
e
e
e · m0 ) = O
e
e λ · 2ℓ .
γ · 2ℓ = O
most O(ℓ) · O(1)
= O(1).
The total cost of all Tι -operations is thus O(γ
e
Using the upper-bound 2ι+κ = O(ℓ) = O(log λ), we see that each Tι+κ -operation costs

 O(1). On the other
1 m1
1
)
=
hand, the result [LCH14] ensures that the cost of Enc is equal to that of O(n · log k) = O ρ · 2κ · log( m
2κ
√ 
√ 
e 2ℓ Tι+κ -operations, and so is itself O
e 2ℓ . The total cost of all 2τ −ι encoding operations is thus
O
√ 
√ 
e 2ℓ = O
e 2ℓ , as required.
O(log2 λ) · O
We assume, as Brakedown’s analysis does (see [Gol+23, § 1]), that the cost Hash of hashing a Tι+κ element is comparable to that of performing a Tι+κ -operation.The total
each Hash operation is thus
 costof
p
√
ℓ
e
e
e
γ · 2 = O λ · 2ℓ .
O(1), so that the total cost of all γ · m0 Hash-operations is O

52

