/-
Copyright (c) 2025 ArkLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import ArkLib.AGM.Basic
import Mathlib.Algebra.Field.ZMod
import Mathlib.Algebra.Order.Star.Basic
import ArkLib.Data.UniPoly.Basic
import Mathlib.Algebra.Polynomial.FieldDivision

/-! ## The KZG Polynomial Commitment Scheme

In this file, we define the KZG polynomial commitment scheme, and prove its correctness and
straightline extraction in the AGM. -/

open UniPoly
open Polynomial

namespace KZG

variable {G : Type*} [Group G] {p : outParam ℕ} [hp : Fact (Nat.Prime p)] [PrimeOrderWith G p]
  {g : G}

variable {G₁ : Type*} [Group G₁] [PrimeOrderWith G₁ p] {g₁ : G₁}
  {G₂ : Type*} [Group G₂] [PrimeOrderWith G₂ p] {g₂ : G₂}
  {Gₜ : Type*} [Group Gₜ] [PrimeOrderWith Gₜ p]
  -- TODO: need to make this a `ZMod p`-linear map
  (pairing : (Additive G₁) →ₗ[ℤ] (Additive G₂) →ₗ[ℤ] (Additive Gₜ))

/-- The vector of length `n + 1` that consists of powers:
  `#v[1, g, g ^ a.val, g ^ (a.val ^ 2), ..., g ^ (a.val ^ n)` -/
def towerOfExponents (g : G) (a : ZMod p) (n : ℕ) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

variable {n : ℕ}

/-- The `srs` (structured reference string) for the KZG commitment scheme with secret exponent `a`
    is defined as `#v[g₁, g₁ ^ a, g₁ ^ (a ^ 2), ..., g₁ ^ (a ^ (n - 1))], #v[g₂, g₂ ^ a]` -/
def generateSrs (n : ℕ) (a : ZMod p) : Vector G₁ (n + 1) × Vector G₂ 2 :=
  (towerOfExponents g₁ a n, towerOfExponents g₂ a 1)

/-- One can verify that the `srs` is valid via using the pairing -/
def checkSrs (proveSrs : Vector G₁ (n + 1)) (verifySrs : Vector G₂ 2) : Prop :=
  ∀ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

/-- To commit to an `n`-tuple of coefficients `coeffs` (corresponding to a polynomial of degree less
    than `n`), we compute: `∏ i : Fin n, srs[i] ^ (p.coeff i)` -/
def commit (srs : Vector G₁ n) (coeffs : Fin n → ZMod p) : G₁ :=
  ∏ i : Fin n, srs[i] ^ (coeffs i).val


/-- When committing `coeffs` using `srs` generated by `towerOfExponents`, and `coeffs` correspond to
  a polynomial `poly : (ZMod p)[X]` of degree `< n + 1`, we get the result `g₁ ^ (p.eval a).val` -/
theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G₁ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g₁ a n) (degreeLTEquiv _ _ poly) = g₁ ^ (poly.1.eval a).val := by
  have {g₁ : G₁} (a b : ℕ) : g₁^a = g₁^b ↔ g₁^(a : ℤ) = g₁^(b : ℤ) := by
    simp only [zpow_natCast]
  simp only [commit, towerOfExponents, Fin.getElem_fin, Vector.getElem_ofFn]
  simp_rw [← pow_mul, Finset.prod_pow_eq_pow_sum,
    eval_eq_sum_degreeLTEquiv poly.property,
      this,
      ←orderOf_dvd_sub_iff_zpow_eq_zpow]

  have hordg₁ : g₁ = 1 ∨ orderOf g₁ = p := by
    have ord_g₁_dvd : orderOf g₁ ∣ p := by rw [← hpG1]; apply orderOf_dvd_natCard
    rw [Nat.dvd_prime hp.out, orderOf_eq_one_iff] at ord_g₁_dvd
    exact ord_g₁_dvd

  rcases hordg₁ with ord1 | ordp
  · simp [ord1]
  · simp [ordp, ←ZMod.intCast_eq_intCast_iff_dvd_sub]
    apply Fintype.sum_congr
    intro x
    exact mul_comm _ _

#check sum_eq_of_subset
#check Polynomial.supp_subset_range_natDegree_succ
#check Polynomial.supp_subset_range
#check degree_eq_natDegree
#check natDegree_lt_iff_degree_lt
#check WithBot.coe_le_coe
#check WithBot.coe_lt_coe

theorem commit_eq_UniPoly {a : ZMod p} (hpG1 : Nat.card G₁ = p)
    (poly : UniPoly (ZMod p)) (hn : poly.degree ≤ n) :
    commit (towerOfExponents g₁ a n)
    ((coeff poly) ∘ Fin.val)
  = g₁ ^ (poly.eval a).val := by
  have {g₁ : G₁} (a b : ℕ) : g₁^a = g₁^b ↔ g₁^(a : ℤ) = g₁^(b : ℤ) := by
    simp only [zpow_natCast]
  simp only [commit, towerOfExponents, Fin.getElem_fin, Vector.getElem_ofFn]
  simp_rw [← pow_mul, Finset.prod_pow_eq_pow_sum,
      ←eval_toPoly_eq_eval,
      eval_eq_sum,
      this,
      ←orderOf_dvd_sub_iff_zpow_eq_zpow]

  have hordg₁ : g₁ = 1 ∨ orderOf g₁ = p := by
    have ord_g₁_dvd : orderOf g₁ ∣ p := by rw [← hpG1]; apply orderOf_dvd_natCard
    rw [Nat.dvd_prime hp.out, orderOf_eq_one_iff] at ord_g₁_dvd
    exact ord_g₁_dvd

  let f := fun e a_1 ↦ a_1 * a ^ e
  have hf : ∀ (i : ℕ), f i 0 = 0 := by
    intro i
    simp_all only [zero_mul, f]
  have hs : poly.toPoly.support ⊆ Finset.range (n + 1) := by
    -- TODO this should be a lemma in UniPoly.
    have hdeg: poly.toPoly.degree = poly.degree := by
      sorry
    have hnatDeg : poly.toPoly.natDegree < (n+1) := by
      by_cases hpolyn0 : poly.toPoly ≠ 0
      · have hle : poly.degree ≤ (n : WithBot ℕ) := by
          simpa [hdeg] using hn
        have hlt : (n : WithBot ℕ) < (n + 1 : WithBot ℕ) := by
          simpa using (WithBot.coe_lt_coe.mpr (Nat.lt_succ_self n))
        simp_rw [natDegree_lt_iff_degree_lt hpolyn0, hdeg]
        exact (lt_of_le_of_lt hle hlt)
      · simp_all only [Decidable.not_not, natDegree_zero,add_pos_iff, zero_lt_one, or_true]
    simp_rw [Polynomial.supp_subset_range hnatDeg]

  rcases hordg₁ with ord1 | ordp
  · simp [ord1]
  · simp [ordp, ←ZMod.intCast_eq_intCast_iff_dvd_sub]
    rw [Polynomial.sum_eq_of_subset
      (R := ZMod p) (S := ZMod p) (p := poly.toPoly)
      f hf (s := Finset.range (n + 1)) hs]
    simp_rw [f, coeff_toPoly, Array.getD_eq_getD_getElem?]
    simp only [mul_comm]
    rw [Fin.sum_univ_eq_sum_range (fun x => a ^ x * poly[x]?.getD 0) (n+1)]


/-- To generate an opening proving that a polynomial `poly` has a certain evaluation at `z`,
  we return the commitment to the polynomial `q(X) = (poly(X) - poly.eval z) / (X - z)` -/
def generateOpening [Fact (Nat.Prime p)] (srs : Vector G₁ (n + 1))
    (coeffs : Fin (n + 1) → ZMod p) (z : ZMod p) : G₁ :=
    letI poly : UniPoly (ZMod p) := UniPoly.mk (Array.ofFn coeffs)
    letI q : UniPoly (ZMod p) := UniPoly.div (poly - UniPoly.C (poly.eval z))
      (UniPoly.X - UniPoly.C z)
    commit srs (fun i : Fin (n + 1) => q.coeff i)

/-- To verify a KZG opening `opening` for a commitment `commitment` at point `z` with claimed
evaluation `v`, we use the pairing to check "in the exponent" that `p(a) - p(z) = q(a) * (a - z)`,
  where `p` is the polynomial and `q` is the quotient of `p` at `z` -/
def verifyOpening (verifySrs : Vector G₂ 2) (commitment : G₁) (opening : G₁)
    (z : ZMod p) (v : ZMod p) : Prop :=
  pairing (commitment / g₁ ^ v.val) (verifySrs[0]) = pairing opening (verifySrs[1] / g₂ ^ z.val)

-- p(a) - p(z) = q(a) * (a - z)
-- e ( C / g₁ ^ v , g₂ ) = e ( O , g₂ ^ a / g₂ ^ z)

-- theorem correctness {g : G} {a : ZMod p} {coeffs : Fin n → ZMod p} {z : ZMod p} :
theorem correctness (n : ℕ) (a : ZMod p) (coeffs : Fin (n + 1) → ZMod p) (z : ZMod p) :
  let poly : UniPoly (ZMod p) := UniPoly.mk (Array.ofFn coeffs)
  let v : ZMod p := poly.eval z
  let (psrs,vsrs) : Vector G₁ (n + 1) × Vector G₂ 2 := generateSrs (g₁:=g₁) (g₂:=g₂) n a
  let C : G₁ := commit psrs coeffs
  let opening: G₁ := generateOpening psrs coeffs z
  verifyOpening pairing (g₁:=g₁) (g₂:=g₂) vsrs C opening z v := by
  intro poly v
  rcases generateSrs (g₁:=g₁) (g₂:=g₂) n a with ⟨psrs, vsrs⟩
  simp
  unfold verifyOpening

  have hcoeffs : coeffs = (coeff poly) ∘ Fin.val := by
    simp_all only [poly]
    ext x : 1
    simp only [Function.comp_apply]
    simp only [Array.getD_eq_getD_getElem?, Array.size_ofFn, Fin.is_lt, getElem?_pos,
    Array.getElem_ofFn, Fin.eta, Option.getD_some]

  have hpdeg : degree poly ≤ n+1 := by
    simp_rw [←Trim.size_eq_degree]
    apply le_trans (Trim.size_le_size (p := poly))
    simp_rw [poly]
    simp




  sorry


end KZG
